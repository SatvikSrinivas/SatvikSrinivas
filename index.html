<!Doctype: HTML w/ Processing>

<html>

  <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
      <title>The 2x2 Rubiks Cube Solver</title>
      <script type="text/javascript" src="js/processing.js"></script>
  </head>
  
  <body>
    <h1>The 2x2 Rubiks Cube Solver</h1>
    <p>The 2x2 Rubik's Cube Solver is a program intended to help beginners learn how to solve the 2x2 Rubik's Cube. Users will be able to input what their physical cube looks like and the program will graphically represent it in 3D on the screen and solve it. The program will not only solve the cube and give the user the answer as to what moves to execute in order to solve it but it will offer a step by step solution explaining each and every step along the way. The program aims to teach the user how to solve the cube rather than simply solving it for them.</p>
    
    <script type="text/processing">
    
      import peasy.*;

void setup() {
  textSizeSetup();
  fullScreen(P3D);
  buttonSetup();
  cubeDrawSetup();
  camSetup();
  instantiateMoves();
  
  //defaultState();
  solvedState();
  //scrambledState();
  //scrambledState(new Move[] {});

  input = new RubiksCube_2x2(cubes);

  animationSetup();
  debugSetup();
  cubeOptionSetup();
  backupCubeSetup();
}

void draw() {   
  welcomeDraw();
  initialDraw();
  startDraw();
  //showDebugCount();
}

void initialDraw() {
  background(backgroundColor); 
  orientCam();
  animationDraw();
  cam.beginHUD();
  title();
  if (!setWelcomeFalse) 
    welcomeMessageDraw();
  cam.endHUD();
}

void startDraw() {
  if (!setWelcomeFalse)
    return;
  checkRotation();
  cam.beginHUD(); //begin2D
  //debug();
  displayCounter();
  buttonDraw();
  cam.endHUD(); //end2D

  showFaceNames();
  solveAlert();
  waitThen();
  resetDraw();
  checkResetMultiplier();
  checkAutoDebug();
}


void RubiksCube_2x2_setup() {
  int i = 0;
  for (int y = -1; y <= 1; y+=2)
    for (int z = 1; z >= -1; z-=2)  
      for (int x = -1; x <= 1; x+=2) {
        PMatrix3D matrix = new PMatrix3D();
        matrix.translate(x, y, z);
        cubies[i++] = new Cubie(matrix, x, y, z);
      }
}

void animationSetup() {
  RubiksCube_2x2_setup();
  instantiateMoves();

  if (solved) 
    moveSequence = sequence(input.algorithmList());

  if (random_Solve) 
    input.scramble(moves).solve(); 

  for (int a = 0; a < moveSequence.length; a++)  
    moveList.add(moveSequence[a]);

  implementMoves();

  if (moves.size() > 0) {
    currentMove = moves.get(counter);
    currentMove.start();
  } else
    currentMove = defaultMove;
}

void instantiateMoves() {
  F = new Move(0, 0, 1, 1);
  Fi = new Move(0, 0, 1, -1);
  B = new Move(0, 0, -1, -1);
  Bi = new Move(0, 0, -1, 1);
  D = new Move(0, 1, 0, 1);
  Di = new Move(0, 1, 0, -1);
  U = new Move(0, -1, 0, -1);
  Ui = new Move(0, -1, 0, 1);
  R = new Move(1, 0, 0, 1);
  Ri = new Move(1, 0, 0, -1);
  L = new Move(-1, 0, 0, -1);
  Li = new Move(-1, 0, 0, 1);
  defaultMove = new Move(-1, -1, -1, -1);
}

void implementMoves() {
  for (int moveIndex = 0; moveIndex < moveList.size(); moveIndex++) {
    if (moveList.get(moveIndex) == F) 
      moves.add(new Move(0, 0, 1, 1));
    else if (moveList.get(moveIndex) == Fi) 
      moves.add(new Move(0, 0, 1, -1));
    else if (moveList.get(moveIndex) == B) 
      moves.add(new Move(0, 0, -1, -1));
    else if (moveList.get(moveIndex) == Bi) 
      moves.add(new Move(0, 0, -1, 1));
    else if (moveList.get(moveIndex) == D) 
      moves.add(new Move(0, 1, 0, 1));
    else if (moveList.get(moveIndex) == Di) 
      moves.add(new Move(0, 1, 0, -1));
    else if (moveList.get(moveIndex) == U) 
      moves.add(new Move(0, -1, 0, -1));
    else if (moveList.get(moveIndex) == Ui) 
      moves.add(new Move(0, -1, 0, 1));
    else if (moveList.get(moveIndex) == R) 
      moves.add(new Move(1, 0, 0, 1));
    else if (moveList.get(moveIndex) == Ri) 
      moves.add(new Move(1, 0, 0, -1));
    else if (moveList.get(moveIndex) == L) 
      moves.add(new Move(-1, 0, 0, -1));
    else if (moveList.get(moveIndex) == Li) 
      moves.add(new Move(-1, 0, 0, 1));
  }
}

Move randomMove() {
  Move[] allMoves = {F, Fi, R, Ri, L, Li, B, Bi, U, Ui, D, Di};
  return allMoves[(int)(random(allMoves.length))];
}

void randomizeMoveList(int n) {
  instantiateMoves();
  Move lastMove = defaultMove;
  for (int i = 0; i < n; i++) {
    Move m = randomMove();
    if (m.equals(lastMove.inverse()) || m.equals(lastMove.complement()) || m.equals(lastMove.opplement()))
      i--;
    else {
      if (m == F) 
        moves.add(new Move(0, 0, 1, 1));
      else if (m == Fi) 
        moves.add(new Move(0, 0, 1, -1));
      else if (m == B) 
        moves.add(new Move(0, 0, -1, -1));
      else if (m == Bi) 
        moves.add(new Move(0, 0, -1, 1));
      else if (m == D) 
        moves.add(new Move(0, 1, 0, 1));
      else if (m == Di) 
        moves.add(new Move(0, 1, 0, -1));
      else if (m == U) 
        moves.add(new Move(0, -1, 0, -1));
      else if (m == Ui) 
        moves.add(new Move(0, -1, 0, 1));
      else if (m == R) 
        moves.add(new Move(1, 0, 0, 1));
      else if (m == Ri) 
        moves.add(new Move(1, 0, 0, -1));
      else if (m == L) 
        moves.add(new Move(-1, 0, 0, -1));
      else if (m == Li) 
        moves.add(new Move(-1, 0, 0, 1));
      lastMove = m;
    }
  }
}

void randomizeMoveList_Solve(int n) {
  randomizeMoveList(n);
  random_Solve = true;
}

Move[] sequence (ArrayList<String> algorithmList) {
  Move[] sequence = new Move[algorithmList.size()];
  for (int i = 0; i < sequence.length; i++)
    switch (algorithmList.get(i)) {
    case F_: 
      sequence[i] = F;
      break;
    case Fi_: 
      sequence[i] = Fi; 
      break;
    case U_: 
      sequence[i] = U;
      break;
    case Ui_: 
      sequence[i] = Ui;
      break;
    case R_: 
      sequence[i] = R;
      break;
    case Ri_: 
      sequence[i] = Ri;
      break;
    case L_: 
      sequence[i] = L;
      break;
    case Li_: 
      sequence[i] = Li;
      break;
    case D_: 
      sequence[i] = D;
      break;
    case Di_: 
      sequence[i] = Di;
      break;
    case B_: 
      sequence[i] = B;
      break;
    case Bi_: 
      sequence[i] = Bi;
      break;
    }
  return sequence;
}

void defaultState() {
  Cube c = new Cube();
  for (int i = 0; i < cubes.length; i++)
    cubes[i] = c;
}

void solvedState () {
  cubes[0] = new Cube(RubiksCube.WBR, RubiksCube.A, 1);
  cubes[1] = new Cube(RubiksCube.WBP, RubiksCube.B, 1);
  cubes[2] = new Cube(RubiksCube.WGR, RubiksCube.C, 1);
  cubes[3] = new Cube(RubiksCube.WGP, RubiksCube.D, 1);
  cubes[4] = new Cube(RubiksCube.YBR, RubiksCube.E, 1);
  cubes[5] = new Cube(RubiksCube.YBP, RubiksCube.F, 1);
  cubes[6] = new Cube(RubiksCube.YGR, RubiksCube.G, 1);
  cubes[7] = new Cube(RubiksCube.YGP, RubiksCube.H, 1);
}

void scrambledState(Move[] moveArray) {
  solvedState();
  RubiksCube_2x2 r = new RubiksCube_2x2(cubes);
  for (Move m : moveArray) {
    scrambleAlgorithm.add(m);
    if (m == F) 
      r.F();
    else if (m == Fi) 
      r.Fi();
    else if (m == B) 
      r.B();
    else if (m == Bi) 
      r.Bi();
    else if (m == D) 
      r.D();
    else if (m == Di) 
      r.Di();
    else if (m == U) 
      r.U();
    else if (m == Ui) 
      r.Ui();
    else if (m == R) 
      r.R();
    else if (m == Ri) 
      r.Ri();
    else if (m == L) 
      r.L();
    else if (m == Li) 
      r.Li();
  }
  cubes = copyOf(r.Cubes);
}

void scrambledState () {
  instantiateMoves();
  Move[] moveArray = {F, Fi, R, Ri, L, Li, B, Bi, U, Ui, D, Di};
  solvedState();
  RubiksCube_2x2 r = new RubiksCube_2x2(cubes);
  for (int i = 0; i < (int)(((20 * Math.random()) + 10)); i++) {
    Move m = moveArray[(int)(random(moveArray.length))];
    scrambleAlgorithm.add(m);
    if (m == F) 
      r.F();
    else if (m == Fi) 
      r.Fi();
    else if (m == B) 
      r.B();
    else if (m == Bi) 
      r.Bi();
    else if (m == D) 
      r.D();
    else if (m == Di) 
      r.Di();
    else if (m == U) 
      r.U();
    else if (m == Ui) 
      r.Ui();
    else if (m == R) 
      r.R();
    else if (m == Ri) 
      r.Ri();
    else if (m == L) 
      r.L();
    else if (m == Li) 
      r.Li();
  }
  cubes = copyOf(r.Cubes);
}

void reset () {
  cubes[0] = new Cube(RubiksCube.WBR, RubiksCube.A, 1);
  cubes[1] = new Cube(RubiksCube.WBP, RubiksCube.B, 1);
  cubes[2] = new Cube(RubiksCube.WGR, RubiksCube.C, 1);
  cubes[3] = new Cube(RubiksCube.WGP, RubiksCube.D, 1);
  cubes[4] = new Cube(RubiksCube.YBR, RubiksCube.E, 1);
  cubes[5] = new Cube(RubiksCube.YBP, RubiksCube.F, 1);
  cubes[6] = new Cube(RubiksCube.YGR, RubiksCube.G, 1);
  cubes[7] = new Cube(RubiksCube.YGP, RubiksCube.H, 1);
  input.update(cubes);
}

void animationRotation(int i) {
  if (abs(cubies[i].z) == 1 && cubies[i].z == currentMove.z)
    rotateZ(currentMove.angle);
  else if (abs(cubies[i].y) == 1 && cubies[i].y == currentMove.y)
    rotateY(currentMove.angle);
  else if (abs(cubies[i].x) == 1 && cubies[i].x == currentMove.x)
    rotateX(currentMove.angle);
  if (F.animating) {
    if (F.z == cubies[i].z) {
      rotateZ(F.angle);
    } else if (F.y == cubies[i].y) {
      rotateY(F.angle);
    } else if (F.x == cubies[i].x) {
      rotateX(F.angle);
    }
  } else if (Fi.animating) {
    if (Fi.z == cubies[i].z) {
      rotateZ(Fi.angle);
    } else if (Fi.y == cubies[i].y) {
      rotateY(Fi.angle);
    } else if (Fi.x == cubies[i].x) {
      rotateX(Fi.angle);
    }
  } else if (U.animating) {
    if (U.z == cubies[i].z) {
      rotateZ(U.angle);
    } else if (U.y == cubies[i].y) {
      rotateY(U.angle);
    } else if (U.x == cubies[i].x) {
      rotateX(U.angle);
    }
  } else if (Ui.animating) {
    if (Ui.z == cubies[i].z) {
      rotateZ(Ui.angle);
    } else if (Ui.y == cubies[i].y) {
      rotateY(Ui.angle);
    } else if (Ui.x == cubies[i].x) {
      rotateX(Ui.angle);
    }
  } else if (R.animating) {
    if (R.z == cubies[i].z) {
      rotateZ(R.angle);
    } else if (R.y == cubies[i].y) {
      rotateY(R.angle);
    } else if (R.x == cubies[i].x) {
      rotateX(R.angle);
    }
  } else if (Ri.animating) {
    if (Ri.z == cubies[i].z) {
      rotateZ(Ri.angle);
    } else if (Ri.y == cubies[i].y) {
      rotateY(Ri.angle);
    } else if (Ri.x == cubies[i].x) {
      rotateX(Ri.angle);
    }
  } else if (L.animating) {
    if (L.z == cubies[i].z) {
      rotateZ(L.angle);
    } else if (L.y == cubies[i].y) {
      rotateY(L.angle);
    } else if (L.x == cubies[i].x) {
      rotateX(L.angle);
    }
  } else if (Li.animating) {
    if (Li.z == cubies[i].z) {
      rotateZ(Li.angle);
    } else if (Li.y == cubies[i].y) {
      rotateY(Li.angle);
    } else if (Li.x == cubies[i].x) {
      rotateX(Li.angle);
    }
  } else if (D.animating) {
    if (D.z == cubies[i].z) {
      rotateZ(D.angle);
    } else if (D.y == cubies[i].y) {
      rotateY(D.angle);
    } else if (D.x == cubies[i].x) {
      rotateX(D.angle);
    }
  } else if (Di.animating) {
    if (Di.z == cubies[i].z) {
      rotateZ(Di.angle);
    } else if (Di.y == cubies[i].y) {
      rotateY(Di.angle);
    } else if (Di.x == cubies[i].x) {
      rotateX(Di.angle);
    }
  } else if (B.animating) {
    if (B.z == cubies[i].z) {
      rotateZ(B.angle);
    } else if (B.y == cubies[i].y) {
      rotateY(B.angle);
    } else if (B.x == cubies[i].x) {
      rotateX(B.angle);
    }
  } else if (Bi.animating) {
    if (Bi.z == cubies[i].z) {
      rotateZ(Bi.angle);
    } else if (Bi.y == cubies[i].y) {
      rotateY(Bi.angle);
    } else if (Bi.x == cubies[i].x) {
      rotateX(Bi.angle);
    }
  }
}

void keyBoardRotation() {
  if (F.animating)
    F.update();
  else if (Fi.animating)
    Fi.update();
  else if (U.animating)
    U.update();
  else if (Ui.animating)
    Ui.update();
  else if (R.animating)
    R.update();
  else if (Ri.animating)
    Ri.update();
  else if (L.animating)
    L.update();
  else if (Li.animating)
    Li.update();
  else if (D.animating)
    D.update();
  else if (Di.animating)
    Di.update();
  else if (B.animating)
    B.update();
  else if (Bi.animating)
    Bi.update();
}

void executeMoveList () { 
  if (running) {
    debugCount++;
    currentMove.update();
    if (currentMove.finished) {
      if (counter < moves.size()-1) {
        counter++;
        currentMove = moves.get(counter);
        currentMove.start();
      }
    }
  }
  if (counter == moves.size() - 1) {
    moves = new ArrayList<Move>();
    solve = false;
    if (solved) {
      keepCounter = true;
      counterKeep = counter;
      executing = false;
      allowKeyPressed = false;
      resetMultiplier();
      if (showScrambleWhileSolvingMessage) {
        showScrambleWhileSolvingMessage = false;
        waitThenScramble = true;
        solveUserButton.pressed = true;
      } 
      if (autoDebug) {
        solveLength = counter + 1;
        autoDebug_verifySolve();
      }
    }
    if (scramble) {
      scramble = false;
      resetScrambling = true;
      keepCounter = false;
      executing = false;
      allowKeyPressed = false;
      resetMultiplier();
      if (showSolveWhileScramblingMessage) {
        showSolveWhileScramblingMessage = false;
        waitThenSolve = true;
        scrambleUserButton.pressed = true;
      } 
      if (autoDebug) {
        autoSolve = true;
        autoDebug_verifySolve = false;
        startNextSolveCount = 0;
      }
    }
    counter = 0;
    resetRunning = true;
    resetKeyPressed = true;
  }
}

int waitThenSolveCounter = 0;
void waitThenSolve() {
  if (waitThenSolveCounter > 50) {
    solve();
    waitThenSolve = false;
    waitThenSolveCounter = 0;
  } else
    waitThenSolveCounter++;
}

int waitThenScrambleCounter = 0;
void waitThenScramble() {
  if (waitThenScrambleCounter > 50) {
    scramble();
    waitThenScramble = false;
    waitThenScrambleCounter = 0;
  } else
    waitThenScrambleCounter++;
}

void solveAlert() {
  if (rotating)
    return;

  if (counter == 0 && solved && solve)
    showSolveAlert = true;
  if (scramble) {
    showSolveAlert = false;
    showTitle = true;
  }
  if (input.isSolved() == false)    
    showSolveAlert = false;

  if (showSolveAlert) {
    solve = false;
    showTitle = false;
    cam.beginHUD();
    fill(black);
    if (solveAlert < 200) {
      rect(bannerX, bannerY - bannerHeight, bannerWidth, bannerHeight);
      fill (red);
      textSize(alertTextSize);
      text(solveAlertMessage, bannerX + (bannerWidth - textWidth(solveAlertMessage)) / 2.0, bannerY - (bannerHeight - textHeight(solveAlertMessage)) / 2.0);
      solveAlert++;
    } else {
      solveAlert = 0;
      showTitle = true;
      showSolveAlert = false;
      solveUserButton.pressed = false;
    }
    cam.endHUD();
  }

  if (showSolveWhileScramblingMessage)
    showSolveWhileScramblingMessage();
  if (showScrambleWhileSolvingMessage)
    showScrambleWhileSolvingMessage();
}

final String solveWhileScramblingMessage = "The Cube Will Solve After It's Done Scrambling";

void showSolveWhileScramblingMessage() {
  cam.beginHUD();
  fill(black);
  rect(bannerX, bannerY - bannerHeight, bannerWidth, bannerHeight);
  fill (red);
  textSize(alertTextSize);
  text(solveWhileScramblingMessage, bannerX + (bannerWidth - textWidth(solveWhileScramblingMessage)) / 2.0, bannerY - (bannerHeight - textHeight(solveWhileScramblingMessage)) / 2.0);     
  cam.endHUD();
}

final String scrambleWhileSolvingMessage = "The Cube Will Scramble After It's Done Solving";

void showScrambleWhileSolvingMessage() {
  cam.beginHUD();
  fill(black);
  rect(bannerX, bannerY - bannerHeight, bannerWidth, bannerHeight);
  fill (red);
  textSize(alertTextSize);
  text(scrambleWhileSolvingMessage, bannerX + (bannerWidth - textWidth(scrambleWhileSolvingMessage)) / 2.0, bannerY - (bannerHeight - textHeight(scrambleWhileSolvingMessage)) / 2.0);     
  cam.endHUD();
}

void animationDraw() {
  scale(36);
  keyBoardRotation();
  fill(215);
  for (int i = 0; i < cubies.length; i++) {
    push();
    if (currentMove != null)
      animationRotation(i);
    cubies[i].show();
    pop();
  }
  executeMoveList();
}

void cubeDraw(float x, float y, float len) {
  cam.beginHUD();
  stroke(black);
  strokeWeight(4);
  fill (white);
  quad(x, y, x - 0.5 * len, y - 0.2725 * len, x, y - 0.4735 * len, x + 0.5 * len, y - 0.2725 * len);
  fill(blue);
  quad(x, y, x, y + 0.615 * len, x + 0.45 * len, y + 0.3 * len, x + 0.5 * len, y - 0.2725 * len);
  fill(red);
  quad(x, y, x, y + 0.615 * len, x - 0.45 * len, y + 0.3 * len, x - 0.5 * len, y - 0.2725 * len);
  cam.endHUD();
}

float cubeDrawLen = 105;

void cubeDrawSetup() {
  float m = (105.0 - 80.0) / (164.52 - 113.76);
  cubeDrawLen = m * (pieceOption1.buttonLength - 164.52) + 105;
}

void cubeDraw(float x, float y) {
  cubeDraw(x, y, cubeDrawLen);
}

void cubeDraw(float x, float y, color c1, color c2, color c3) {
  cubeDraw(x, y, cubeDrawLen, c1, c2, c3);
}

ArrayList<Cube> cubeOptions = new ArrayList<Cube>();

void cubeOptionSetup () {
  Cube[] cubes = new Cube[8];
  cubes[0] = new Cube(RubiksCube.WBR, 'A', 1);
  cubes[1] = new Cube(RubiksCube.WBP, 'A', 1);
  cubes[2] = new Cube(RubiksCube.WGR, 'A', 1);
  cubes[3] = new Cube(RubiksCube.WGP, 'A', 1);
  cubes[4] = new Cube(RubiksCube.YBR, 'A', 1);
  cubes[5] = new Cube(RubiksCube.YBP, 'A', 1);
  cubes[6] = new Cube(RubiksCube.YGR, 'A', 1);
  cubes[7] = new Cube(RubiksCube.YGP, 'A', 1);
  for (Cube c : cubes)
    cubeOptions.add(c);
}

void cubeDraw(float x, float y, float len, color c1, color c2, color c3) {
  cam.beginHUD();
  stroke(black);
  strokeWeight(4);
  fill (c1);
  quad(x, y, x - 0.5 * len, y - 0.2725 * len, x, y - 0.4735 * len, x + 0.5 * len, y - 0.2725 * len);
  fill(c2);
  quad(x, y, x, y + 0.615 * len, x + 0.45 * len, y + 0.3 * len, x + 0.5 * len, y - 0.2725 * len);
  fill(c3);
  quad(x, y, x, y + 0.615 * len, x - 0.45 * len, y + 0.3 * len, x - 0.5 * len, y - 0.2725 * len);
  cam.endHUD();
}

boolean welcome = true, setWelcomeFalse = false;
float welcomeAngle = 0, welcomeIncrement = 0.025;

void welcomeDraw() {
  if (!welcome)
    return;
  welcomeAngle += welcomeIncrement;
  rotateY((float)welcomeAngle);
  if (welcomeAngle >= 2 * Math.PI) {
    welcomeAngle = 0;
    if (setWelcomeFalse) {
      welcome = false;
      activateCam();
    }
  }
}

void welcomeMessageDraw() {
  textSize (0.65 * titleTextSize);
  float x = (displayWidth - textWidth(welcomeText)) / 2.0, y = 0.925 * displayHeight, m = 1.10;
  fill (black);
  rect (x - ((m - 1) / 2.0) * textWidth(welcomeText), y - 0.825 * textHeight(welcomeText), m * textWidth(welcomeText), m * textHeight(welcomeText));
  fill (white);
  text(welcomeText, x, y);
}


ArrayList <UserButton> allButtons = new ArrayList<UserButton>();

final String square = "sqaure", circle = "circle", rect = "rect", option = "option";

final String homeName = "Home";
UserButton Home = new UserButton(homeName);

final String controlsName = "Controls";
UserButton Controls = new UserButton(controlsName);

final String scrambleName = "Scramble";
UserButton scrambleUserButton = new UserButton(scrambleName);

final String solveName = "Solve";
UserButton solveUserButton = new UserButton(solveName);

final String inputCubeName = "Input Your Own Cube";
UserButton inputCubeUserButton = new UserButton(inputCubeName);

UserButton[] UserButtons = {Home, Controls, scrambleUserButton, solveUserButton, inputCubeUserButton};

final String leftName = "left";
UserButton left = new UserButton(leftName);
final String upName = "up";
UserButton up = new UserButton(upName);
final String rightName = "right";
UserButton right = new UserButton(rightName);
final String downName = "down";
UserButton down = new UserButton(downName);
final String middleName = "middle";
UserButton middle = new UserButton(middleName);
final String cancelName = "cancel";
UserButton cancel = new UserButton(cancelName);

final String fName = "F";
UserButton f = new UserButton(fName);
final String fiName = "Fi";
UserButton fi = new UserButton(fiName);
final String rName = "R";
UserButton r = new UserButton(rName);
final String riName = "Ri";
UserButton ri = new UserButton(riName);
final String uName = "U";
UserButton u = new UserButton(uName);
final String uiName = "Ui";
UserButton ui = new UserButton(uiName);
final String lName = "L";
UserButton l = new UserButton(lName);
final String liName = "Li";
UserButton li = new UserButton(liName);
final String dName = "D";
UserButton d = new UserButton(dName);
final String diName = "Di";
UserButton di = new UserButton(diName);
final String bName = "B";
UserButton b = new UserButton(bName);
final String biName = "Bi";
UserButton bi = new UserButton(biName);

UserButton[] controlButtons = {left, right, up, down, middle, cancel, f, fi, r, ri, u, ui, l, li, d, di, b, bi};

final String pieceOption1Name = "pieceOption1";
UserButton pieceOption1 = new UserButton(pieceOption1Name);
final String pieceOption2Name = "pieceOption2";
UserButton pieceOption2 = new UserButton(pieceOption2Name);
final String pieceOption3Name = "pieceOption3";
UserButton pieceOption3 = new UserButton(pieceOption3Name);
final String pieceOption4Name = "pieceOption4";
UserButton pieceOption4 = new UserButton(pieceOption4Name);
final String pieceOption5Name = "pieceOption5";
UserButton pieceOption5 = new UserButton(pieceOption5Name);
final String pieceOption6Name = "pieceOption6";
UserButton pieceOption6 = new UserButton(pieceOption6Name);
final String pieceOption7Name = "pieceOption7";
UserButton pieceOption7 = new UserButton(pieceOption7Name);
final String pieceOption8Name = "pieceOption8";
UserButton pieceOption8 = new UserButton(pieceOption8Name);

final String colorOption1Name = "colorOption1";
UserButton colorOption1 = new UserButton(colorOption1Name);
final String colorOption2Name = "colorOption2";
UserButton colorOption2 = new UserButton(colorOption2Name);
final String colorOption3Name = "colorOption3";
UserButton colorOption3 = new UserButton(colorOption3Name);

UserButton[] optionButtons = {pieceOption1, pieceOption2, pieceOption3, pieceOption4, pieceOption5, pieceOption6, pieceOption7, pieceOption8, colorOption1, colorOption2, colorOption3};

final String doneButtonName = "Click Here When Done";
UserButton doneButton = new UserButton(doneButtonName);

void buttonSetup() {
  scrambleUserButton.setup();
  solveUserButton.setup();
  inputCubeUserButton.setup();
  Controls.setup();
  Home.setup();
  cancel.setup();
  left.setup();
  up.setup();
  right.setup();
  down.setup();
  middle.setup();
  f.setup();
  fi.setup();
  r.setup();
  ri.setup();
  u.setup();
  ui.setup();
  l.setup();
  li.setup();
  d.setup();
  di.setup();
  b.setup();
  bi.setup();
  pieceOption1.setup();
  pieceOption2.setup();
  pieceOption3.setup();
  pieceOption4.setup();
  pieceOption5.setup();
  pieceOption6.setup();
  pieceOption7.setup();
  pieceOption8.setup();
  colorOption1.setup();
  colorOption2.setup();
  colorOption3.setup();
  doneButton.setup();
  allButtonSetup();
}

void allButtonSetup() {
  for (UserButton uB : UserButtons)
    allButtons.add(uB);
  for (UserButton uB : controlButtons)
    allButtons.add(uB);
  for (UserButton uB : optionButtons)
    allButtons.add(uB);
}

void controlButtonsDraw() {
  for (UserButton uB : controlButtons)
    uB.draw();
}

color controlsBgColor = color (252, 228, 8);
float controlsText_X = 0, controlsText_Y = 0, controlsX = 0, controlsY = 0, controlsWidth = 0, controlsHeight = 0;

void controlsPressed() {
  if (inputCubeUserButton.pressed || executing) {
    Controls.pressed = false;
    return;
  }
  fill(controlsBgColor);
  rect(controlsX, controlsY, controlsWidth, controlsHeight);
  fill(black);
  textSize(controlsTextSize);
  text(controlsText, controlsText_X, controlsText_Y);
  fill(blue);
  text(controlsText, controlsText_X + 1, controlsText_Y - 1);
  stroke(blue);
  float shift = 0.01435 * controlsHeight;
  strokeWeight(2.34);
  line(controlsText_X, controlsText_Y + shift, controlsText_X + textWidth(controlsText), controlsText_Y + shift);
  controlButtonsDraw();
}

void buttonDraw() {
  if (rotating)
    return;
  for (UserButton uB : UserButtons)
    uB.draw();
  if (Controls.pressed)
    controlsPressed();
  if (inputCubeUserButton.pressed) 
    inputCubePressed();
  doneButton.draw();
}

void showMessage(String s) {
  fill(black);
  rect(bannerX, bannerY - bannerHeight, bannerWidth, bannerHeight);
  fill (white);
  textSize(1.25 * alertTextSize);
  text(s, bannerX + (bannerWidth - textWidth(s)) / 2.0, bannerY - (bannerHeight - textHeight(s)) / 2.0);
}

void showOptions_Pieces() {
  cam.beginHUD(); 
  pieceOption1.draw();
  pieceOption2.draw();
  pieceOption3.draw();
  pieceOption4.draw();
  pieceOption5.draw();
  pieceOption6.draw();
  pieceOption7.draw();
  pieceOption8.draw();
  cam.endHUD();
}

void showOptions_Colors() {
  cam.beginHUD(); 
  colorOption1.draw();
  colorOption2.draw();
  colorOption3.draw();
  cam.endHUD();
}

int positionCounter = 0, faceIndex = 0;

void promptUser_PositionInfo () {
  if (positionCounter == 7) {
    selectedCube = cubeOptions.remove(0);
    promptUser_Position = !promptUser_Position;
    return;
  }
  if (positionCounter == 4 && !userCubeFlipped) {
    flipCubeView = true;
    promptUser_FlipCube();
  } else {
    showMessage("Which Piece Is In The Highlighted Position?");
    switch (positionCounter) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 5:
    case 6:
    case 7:
      highlight(positionCounter % 4);
      break;
    case 4:
      highlight(7);
      break;
    }
    showOptions_Pieces();
  }
}

boolean userCubeFlipped = false, userCubeFlipped_Animation = false;

void flipReset() {   
  Ri();
  Ri();
  L();
  L();
  U();
  Di();
}

void promptUser_FlipCube() {
  deactivateOptionButtons();
  showMessage("Please Flip Your Rubik's Cube As Shown Below.");
}

void promptUser_OrientationInfo() {
  if (positionCounter == 4) {
    flipCubeView = true;
    promptUser_FlipCube();
  } else
    unhighlight(positionCounter % 4);
  if (userCubeFlipped_Animation || positionCounter < 4) {
    flipCubeView = false;
    activateOptionButtons_Orientation();
    showMessage("Which Color Is On The Highlighted Face?");
    if (positionCounter != 4)
      highlight(positionCounter % 4, faceIndex);
    showOptions_Colors();
  }
}

boolean promptUser_Position = true;
Cube selectedCube = new Cube();
String selectedColor = "";

void inputCubePressed() {
  if (inputCubeUserButton.pressed)
    if (promptUser_Position)
      promptUser_PositionInfo();
    else
      promptUser_OrientationInfo();
}

Cube[] backupCubes = new Cube[8];

void backupCubeSetup() {
  for (int i = 0; i < 8; i++)
    backupCubes[i] = new Cube();
}

void updateInputCube() {
  int orientation = -1;
  switch (selectedColor) {
  case RubiksCube.w:
  case RubiksCube.y:
    orientation = 1;
    break;
  case RubiksCube.b:
  case RubiksCube.g:
    orientation = 2;
    break;
  case RubiksCube.r:
  case RubiksCube.p:
    orientation = 3;
    break;
  } 
  cubes[positionCounter % 4] = new Cube (selectedCube.name, char (positionCounter % 4 + 65), orientation);
  input.update();
  animationSetup();
  if (positionCounter < 7)
    positionCounter++;
  else {  
    resetInputCube();
    moves = new ArrayList<Move>();
  }
}

float showOptions_PiecesWidthFloat = 0, showOptions_PiecesX_Float = 0, showOptions_PiecesY_Float = 0;

int suspendCount = 0;

void cubeOptionRemove(int i) {
  selectedCube = cubeOptions.remove(i);
  switch(suspendCount) {
  case 0:
    pieceOption8.suspend();
    break;
  case 1:
    pieceOption7.suspend();
    break;
  case 2:
    pieceOption6.suspend();
    break;
  case 3:
    pieceOption5.suspend();
    break;
  case 4:
    pieceOption4.suspend();
    break;
  case 5:
    pieceOption3.suspend();
    break;
  case 6:
    pieceOption2.suspend();
    break;
  case 7:
    pieceOption1.suspend();
    break;
  }
  suspendCount++;
}


void camSetup() {
  double screenWidth = displayWidth, screenHeight = displayHeight, screenRatio = screenWidth / screenHeight;
  double distance = -140.625 * (screenRatio - 1.6) + 425;
  cam = new PeasyCam(this, distance);
  cam.setMinimumDistance(distance);
  cam.setMaximumDistance(distance);
  cam.setResetOnDoubleClick(false);  
  deactivateCam();
}

void activateCam() {
  camActive = true;
  cam.setActive(camActive);
}

void deactivateCam() {
  camActive = false;
  cam.setActive(camActive);
}

void orientCam() {
  rotateX((float)-Math.PI/5.5);
  rotateY((float)Math.PI/4);
  flipCubeView();
}

boolean flipCubeView = false;
float flipSpeed = 8.5, flipInterval = (float)(Math.PI / 1000), flipCubeAngleX = 0, flipCubeAngleY = 0;
int flipCubeLastQuestionWaitTime = 0;

void flipCubeView_LastQuestion () {
  if (flipCubeView && flipCubeAngleX < Math.PI && flipCubeAngleY < Math.PI/2) {
    flipCubeAngleX += 2 * flipSpeed * flipInterval;
    flipCubeAngleY += flipSpeed * flipInterval;
  }
  if (flipCubeAngleX >= Math.PI && flipCubeAngleY >= Math.PI/2) {
    flipCubeLastQuestionWaitTime++;
    if (flipCubeLastQuestionWaitTime > 40) {
      flipCubeAngleX = 0;
      flipCubeAngleY = 0;
      flipCubeView = false;
      flipCubeLastQuestionWaitTime = 0;
    }
    if (flipCubeLastQuestionWaitTime == 0 && userCubeFlipped) {
      userCubeFlipped_Animation = true;
      flipReset();
      cubes = input.Cubes();
      input.update();
      flipCubeView = false;
    }
  }
}

boolean flipCubeView_User = false;

void flipCubeView () {
  if (flipCubeView_User && flipCubeAngleX < Math.PI && flipCubeAngleY < Math.PI/2) {
    flipCubeAngleX += 2 * flipSpeed * flipInterval;
    flipCubeAngleY += flipSpeed * flipInterval;
    if (flipCubeAngleX >= Math.PI && flipCubeAngleY >= Math.PI/2) {
      flipReset();
      flipCubeAngleX = 0;
      flipCubeAngleY = 0;
      flipCubeView_User = false;
    }
  }
  rotateX(flipCubeAngleX);
  rotateY(flipCubeAngleY);
  flipCubeView_LastQuestion();
}

void resetCam() {
  if (goingHome)
    return;
  cam.reset(300);
  atHome = true;
}

void checkFreezeCube() {
  if (mousePressed) {
    mouseClickedX = mouseX;
    mouseClickedY = mouseY;
  }
  if (mouseInsideButton() && !Home.insideButton())
    freezeCam();
  else
    unfreezeCam();
}

void checkFreezeCam() {
  if (freezeCam && frozenState != null)
    cam.setState(frozenState);
}

void freezeCam() {
  freezeCam = true;
  frozenState = cam.getState();
}

void unfreezeCam() {
  freezeCam = false;
  frozenState = null;
}

int mouseX_rotation = -1, mouseY_rotation = -1, mouseClickedX = -1, mouseClickedY = -1, 
  mouseX_firstClick = -1, mouseY_firstClick = -1;
boolean firstClick = true, mouseHeld = false;

boolean mouseInsideButton() {
  if (mousePressed) {
    if (mouseHeld == false) {
      mouseClickedX = mouseX;
      mouseClickedY = mouseY;
    }
    mouseHeld = true;
  } else
    mouseHeld = false;
  for (UserButton uB : allButtons)
    if (!rotating && uB.insideButton() && uB.active == true && uB.suspend == false)
      return true;
  return false;
}

int mouseHeld_MarginForError = 1;

boolean mouseHeld_Moved () {
  return abs(mouseX_firstClick - mouseX) > mouseHeld_MarginForError || abs(mouseY_firstClick  - mouseY) > mouseHeld_MarginForError;
}

void checkRotation() {
  if (mousePressed) {
    mouseHoldCount++;  
    mouseX_rotation = mouseX;
    mouseY_rotation = mouseY;
    if (firstClick) { 
      mouseX_firstClick = mouseX;
      mouseY_firstClick = mouseY;
      firstClick = false;
    }
    if (mouseHoldCount > mouseHoldThreshold) 
      rotating = true;
    if (mouseHeld_Moved()) {
      rotating = true;
      atHome = false;
    }
  } else if (!mousePressed) {
    rotating = false;
    firstClick = true;
  }
}


public class Cube extends RubiksCube {

  private String name;
  private char position;
  private int orientation;

  public Cube() {
    name = "default";
    position = 'z';
    orientation = 0;
  }

  public Cube(String cubeName, char cubePosition, int cubeOrientation) {
    this.name = cubeName;
    this.position = cubePosition;
    this.orientation = cubeOrientation;
  }

  public Cube copy () {
    return new Cube(name, position, orientation);
  }

  public String name() {
    return this.name;
  }

  public void changeNameTo(String s) {
    this.name = s;
  }

  public char position() {
    return this.position;
  }

  public void changePositionTo(char c) {
    this.position = c;
  }

  public int orientation() {
    return this.orientation;
  }

  public void changeOrientationTo(int i) {
    this.orientation = i;
  }

  public String[] faces() {
    String f1 = "", f2 = "", f3 = "";
    switch (this.name()) {
    case WBR:
      f1 = w;
      f2 = b;
      f3 = r;
      break;
    case WBP:
      f1 = w;
      f2 = b;
      f3 = p;
      break;
    case WGR:
      f1 = w;
      f2 = g;
      f3 = r;
      break;
    case WGP:
      f1 = w;
      f2 = g;
      f3 = p;
      break;
    case YBR:
      f1 = y;
      f2 = b;
      f3 = r;
      break;
    case YBP:
      f1 = y;
      f2 = b;
      f3 = p;
      break;
    case YGR:
      f1 = y;
      f2 = g;
      f3 = r;
      break;
    case YGP:
      f1 = y;
      f2 = g;
      f3 = p;
      break;
    }
    String[] faces = { f1, f2, f3 };
    return faces;
  }

  public int[] faceNumbers() {
    int num1 = 0, num2 = 1, num3 = 2;
    if (this.orientationType() == 2) {
      num2 = 2;
      num3 = 1;
    }
    int[] faceNumbers = { num1, num2, num3 };
    return faceNumbers;
  }

  public int orientationType() {
    int orientationType = 1;
    switch (this.position()) {
    case A:
    case D:
    case F:
    case G:
      switch (this.name()) {
      case WBP:
      case WGR:
      case YBR:
      case YGP:
        orientationType = 2;
        break;
      }
      break;
    case B:
    case C:
    case E:
    case H:
      switch (this.name()) {
      case WBR:
      case WGP:
      case YBP:
      case YGR:
        orientationType = 2;
        break;
      }
      break;
    }
    return orientationType;
  }

  public String[] faceDesignations() {
    String u = "U", d = "D", r = "R", l = "L", b = "B", f = "F";
    String face1 = "", face2 = "", face3 = "";
    switch (this.position()) {
    case A:
      face1 = u;
      face2 = f;
      face3 = l;
      break;
    case B:
      face1 = u;
      face2 = f;
      face3 = r;
      break;
    case C:
      face1 = u;
      face2 = b;
      face3 = l;
      break;
    case D:
      face1 = u;
      face2 = b;
      face3 = r;
      break;
    case E:
      face1 = d;
      face2 = f;
      face3 = l;
      break;
    case F:
      face1 = d;
      face2 = f;
      face3 = r;
      break;
    case G:
      face1 = d;
      face2 = b;
      face3 = l;
      break;
    case H:
      face1 = d;
      face2 = b;
      face3 = r;
      break;
    }
    String[] faceDesignations = { face1, face2, face3 };
    return faceDesignations;
  }

  public String[] faceColors() {
    String face1 = "", face2 = "", face3 = "";
    String[] faces = this.faces();
    int[] faceNumbers = this.faceNumbers();
    if (this.orientationType() == 1) {
      switch (this.orientation()) {
      case 1:
        face1 = faces[faceNumbers[0]];
        face2 = faces[faceNumbers[1]];
        face3 = faces[faceNumbers[2]];
        break;
      case 2:
        face1 = faces[faceNumbers[1]];
        face2 = faces[faceNumbers[2]];
        face3 = faces[faceNumbers[0]];
        break;
      case 3:
        face1 = faces[faceNumbers[2]];
        face2 = faces[faceNumbers[0]];
        face3 = faces[faceNumbers[1]];
        break;
      }
    } else {
      switch (this.orientation()) {
      case 1:
        face1 = faces[faceNumbers[0]];
        face2 = faces[faceNumbers[1]];
        face3 = faces[faceNumbers[2]];
        break;
      case 2:
        face1 = faces[faceNumbers[2]];
        face2 = faces[faceNumbers[0]];
        face3 = faces[faceNumbers[1]];
        break;
      case 3:
        face1 = faces[faceNumbers[1]];
        face2 = faces[faceNumbers[2]];
        face3 = faces[faceNumbers[0]];
        break;
      }
    }
    String[] faceColors = { face1, face2, face3 };
    return faceColors;
  }

  public int conjugateOrientation(int n) {
    switch (colorID(this.faceColors()[n])) {
    case 1:
      if (this.orientation() == 2)
        return 3;
      else
        return 2;
    case 2:
      if (this.orientation() == 1)
        return 3;
      else
        return 1;
    case 3:
      if (this.orientation() == 1)
        return 2;
      else
        return 1;
    }
    return -1;
  }

  public int indexOf(String c) {
    int index = -1;
    for (int i = 0; i < this.faceColors().length; i++)
      if (this.faceColors()[i].equals(c))
        index = i;
    return index;
  }

  public boolean containsWhite() {
    if (this.name().equals(RubiksCube.WBR) || this.name().equals(RubiksCube.WGR)
      || this.name().equals(RubiksCube.WBP) || this.name().equals(RubiksCube.WGP))
      return true;
    return false;
  }

  public boolean containsYellow() {
    if (this.name().equals(RubiksCube.YBR) || this.name().equals(RubiksCube.YGR)
      || this.name().equals(RubiksCube.YBP) || this.name().equals(RubiksCube.YGP))
      return true;
    return false;
  }

  public boolean isDiagonalTo(Cube arg, char layer) {
    switch (layer) {
    case 'U':
      if ((this.position() == 'A' && arg.position() == 'D') || (this.position() == 'B' && arg.position() == 'C')
        || (this.position() == 'D' && arg.position() == 'A')
        || (this.position() == 'C' && arg.position() == 'B'))
        return true;
    }
    return false;
  }

  public boolean isInUlayer() {
    if (this.position() == 'A' || this.position() == 'C' || this.position() == 'D' || this.position() == 'B')
      return true;
    return false;
  }

  public boolean isInDlayer() {
    if (this.position() == 'E' || this.position() == 'F' || this.position() == 'H' || this.position() == 'G')
      return true;
    return false;
  }

  public boolean isInLlayer() {
    if (this.position() == 'A' || this.position() == 'E' || this.position() == 'G' || this.position() == 'C')
      return true;
    return false;
  }

  public boolean isInRlayer() {
    if (this.position() == 'B' || this.position() == 'D' || this.position() == 'H' || this.position() == 'F')
      return true;
    return false;
  }

  public boolean isInFlayer() {
    if (this.position() == 'A' || this.position() == 'B' || this.position() == 'F' || this.position() == 'E')
      return true;
    return false;
  }

  public boolean isInBlayer() {
    if (this.position() == 'C' || this.position() == 'G' || this.position() == 'H' || this.position() == 'D')
      return true;
    return false;
  }

  public String toString() {
    return this.name + " (" + this.position + this.orientation + ")";
  }
}

class Cubie {

  PMatrix3D matrix;
  int x, y, z;
  Face[] faces = new Face[6];
  float f = (float)Math.pow(10, -14);

  Cubie(PMatrix3D m, int x, int y, int z) {
    matrix = m;
    this.x = x;
    this.y = y;
    this.z = z;
    faces[0] = new Face(new PVector(0, 0, 0.25), baseColor); //Front
    faces[1] = new Face(new PVector(0, 0, -0.25), baseColor); //Back
    faces[2] = new Face(new PVector(0, f, 0.25), baseColor); // Up
    faces[3] = new Face(new PVector(0, f, -0.25), baseColor); // Down
    faces[4] = new Face(new PVector(f, 0, -0.25), baseColor); // Left
    faces[5] = new Face(new PVector(f, 0, 0.25), baseColor); // Right
    addInputColors();
  }

  void addInputColors() {
    int i = -1;
    switch(""+x+y+z) {
    case "-1-11" : // Cube A
      i = 0; 
      faces[0] = new Face(new PVector(0, 0, 0.25), correspondingColor(input.Cubes()[i].faceColors()[1])); 
      faces[2] = new Face(new PVector(0, f, 0.25), correspondingColor(input.Cubes()[i].faceColors()[0]));  
      faces[4] = new Face(new PVector(f, 0, -0.25), correspondingColor(input.Cubes()[i].faceColors()[2]));
      break;
    case "1-11" : // Cube B
      i = 1;
      faces[0] = new Face(new PVector(0, 0, 0.25), correspondingColor(input.Cubes()[i].faceColors()[1])); 
      faces[2] = new Face(new PVector(0, f, 0.25), correspondingColor(input.Cubes()[i].faceColors()[0]));  
      faces[5] = new Face(new PVector(f, 0, 0.25), correspondingColor(input.Cubes()[i].faceColors()[2]));
      break;
    case "-1-1-1" : // Cube C
      i = 2;
      faces[1] = new Face(new PVector(0, 0, -0.25), correspondingColor(input.Cubes()[i].faceColors()[1])); 
      faces[2] = new Face(new PVector(0, f, 0.25), correspondingColor(input.Cubes()[i].faceColors()[0]));  
      faces[4] = new Face(new PVector(f, 0, -0.25), correspondingColor(input.Cubes()[i].faceColors()[2]));
      break;
    case "1-1-1" :   // Cube D
      i = 3;
      faces[1] = new Face(new PVector(0, 0, -0.25), correspondingColor(input.Cubes()[i].faceColors()[1])); 
      faces[2] = new Face(new PVector(0, f, 0.25), correspondingColor(input.Cubes()[i].faceColors()[0]));
      faces[5] = new Face(new PVector(f, 0, 0.25), correspondingColor(input.Cubes()[i].faceColors()[2]));
      break;
    case "-111" : // Cube E
      i = 4;
      faces[0] = new Face(new PVector(0, 0, 0.25), correspondingColor(input.Cubes()[i].faceColors()[1])); 
      faces[3] = new Face(new PVector(0, f, -0.25), correspondingColor(input.Cubes()[i].faceColors()[0]));  
      faces[4] = new Face(new PVector(f, 0, -0.25), correspondingColor(input.Cubes()[i].faceColors()[2]));
      break;
    case "111" : // Cube F
      i = 5;
      faces[0] = new Face(new PVector(0, 0, 0.25), correspondingColor(input.Cubes()[i].faceColors()[1])); 
      faces[3] = new Face(new PVector(0, f, -0.25), correspondingColor(input.Cubes()[i].faceColors()[0]));  
      faces[5] = new Face(new PVector(f, 0, 0.25), correspondingColor(input.Cubes()[i].faceColors()[2]));
      break;
    case "-11-1" : // Cube G
      i = 6; 
      faces[1] = new Face(new PVector(0, 0, -0.25), correspondingColor(input.Cubes()[i].faceColors()[1])); 
      faces[3] = new Face(new PVector(0, f, -0.25), correspondingColor(input.Cubes()[i].faceColors()[0]));  
      faces[4] = new Face(new PVector(f, 0, -0.25), correspondingColor(input.Cubes()[i].faceColors()[2]));
      break;
    case "11-1" : // Cube H
      i = 7;
      faces[1] = new Face(new PVector(0, 0, -0.25), correspondingColor(input.Cubes()[i].faceColors()[1])); 
      faces[3] = new Face(new PVector(0, f, -0.25), correspondingColor(input.Cubes()[i].faceColors()[0]));  
      faces[5] = new Face(new PVector(f, 0, 0.25), correspondingColor(input.Cubes()[i].faceColors()[2]));
      break;
    }
  }

  void addSolvedColors() {
    switch(""+x+y+z) {
    case "-1-11" : // Cube A
      faces[0] = new Face(new PVector(0, 0, 0.25), blue); 
      faces[2] = new Face(new PVector(0, f, 0.25), white);  
      faces[4] = new Face(new PVector(f, 0, -0.25), red); 
      break;
    case "1-11" : // Cube B
      faces[0] = new Face(new PVector(0, 0, 0.25), blue); 
      faces[2] = new Face(new PVector(0, f, 0.25), white);
      faces[5] = new Face(new PVector(f, 0, 0.25), purple);
      break;
    case "-1-1-1" : // Cube C
      faces[1] = new Face(new PVector(0, 0, -0.25), green);
      faces[2] = new Face(new PVector(0, f, 0.25), white);  
      faces[4] = new Face(new PVector(f, 0, -0.25), red); 
      break;
    case "1-1-1" :   // Cube D
      faces[1] = new Face(new PVector(0, 0, -0.25), green); 
      faces[2] = new Face(new PVector(0, f, 0.25), white);
      faces[5] = new Face(new PVector(f, 0, 0.25), purple);
      break;
    case "-111" : // Cube E
      faces[0] = new Face(new PVector(0, 0, 0.25), blue); 
      faces[3] = new Face(new PVector(0, f, -0.25), yellow);
      faces[4] = new Face(new PVector(f, 0, -0.25), red); 
      break;
    case "111" : // Cube F
      faces[0] = new Face(new PVector(0, 0, 0.25), blue); 
      faces[3] = new Face(new PVector(0, f, -0.25), yellow);
      faces[5] = new Face(new PVector(f, 0, 0.25), purple);
      break;
    case "-11-1" : // Cube G
      faces[1] = new Face(new PVector(0, 0, -0.25), green);
      faces[3] = new Face(new PVector(0, f, -0.25), yellow); 
      faces[4] = new Face(new PVector(f, 0, -0.25), red); 
      break;
    case "11-1" : // Cube H
      faces[1] = new Face(new PVector(0, 0, -0.25), green); 
      faces[3] = new Face(new PVector(0, f, -0.25), yellow);
      faces[5] = new Face(new PVector(f, 0, 0.25), purple);
      break;
    }
  }

  color correspondingColor(String c) {
    switch(c) {
    case RubiksCube.w : 
      return white;
    case RubiksCube.y : 
      return yellow;
    case RubiksCube.g : 
      return green;
    case RubiksCube.b : 
      return blue;
    case RubiksCube.r : 
      return red;
    case RubiksCube.p : 
      return purple;
    }
    return baseColor;
  }

  void updateColorsL() {
    color[] oldColors = new color [faces.length];
    for (int i = 0; i < oldColors.length; i++)
      oldColors[i] = faces[i].c;
    this.setColor(0, oldColors[2]);
    this.setColor(1, oldColors[3]);
    this.setColor(2, oldColors[1]);
    this.setColor(3, oldColors[0]);
  }

  void updateColorsLi() {
    color[] oldColors = new color [faces.length];
    for (int i = 0; i < oldColors.length; i++)
      oldColors[i] = faces[i].c;
    this.setColor(2, oldColors[0]);
    this.setColor(3, oldColors[1]);
    this.setColor(1, oldColors[2]);
    this.setColor(0, oldColors[3]);
  }

  void updateColorsR() {
    color[] oldColors = new color [faces.length];
    for (int i = 0; i < oldColors.length; i++)
      oldColors[i] = faces[i].c;
    this.setColor(2, oldColors[0]);
    this.setColor(3, oldColors[1]);
    this.setColor(1, oldColors[2]);
    this.setColor(0, oldColors[3]);
  }

  void updateColorsRi() {
    color[] oldColors = new color [faces.length];
    for (int i = 0; i < oldColors.length; i++)
      oldColors[i] = faces[i].c;
    this.setColor(0, oldColors[2]);
    this.setColor(1, oldColors[3]);
    this.setColor(2, oldColors[1]);
    this.setColor(3, oldColors[0]);
  }

  void updateColorsD() {
    color[] oldColors = new color [faces.length];
    for (int i = 0; i < oldColors.length; i++)
      oldColors[i] = faces[i].c;
    this.setColor(5, oldColors[0]);
    this.setColor(4, oldColors[1]);
    this.setColor(0, oldColors[4]);
    this.setColor(1, oldColors[5]);
  }

  void updateColorsDi() {
    color[] oldColors = new color [faces.length];
    for (int i = 0; i < oldColors.length; i++)
      oldColors[i] = faces[i].c;
    this.setColor(0, oldColors[5]);
    this.setColor(1, oldColors[4]);
    this.setColor(4, oldColors[0]);
    this.setColor(5, oldColors[1]);
  }

  void updateColorsUi() {
    color[] oldColors = new color [faces.length];
    for (int i = 0; i < oldColors.length; i++)
      oldColors[i] = faces[i].c;
    this.setColor(5, oldColors[0]);
    this.setColor(4, oldColors[1]);
    this.setColor(0, oldColors[4]);
    this.setColor(1, oldColors[5]);
  }

  void updateColorsU() {
    color[] oldColors = new color [faces.length];
    for (int i = 0; i < oldColors.length; i++)
      oldColors[i] = faces[i].c;
    this.setColor(0, oldColors[5]);
    this.setColor(1, oldColors[4]);
    this.setColor(4, oldColors[0]);
    this.setColor(5, oldColors[1]);
  }

  void updateColorsB() {
    color[] oldColors = new color [faces.length];
    for (int i = 0; i < oldColors.length; i++)
      oldColors[i] = faces[i].c;
    this.setColor(4, oldColors[2]);
    this.setColor(5, oldColors[3]);
    this.setColor(3, oldColors[4]);
    this.setColor(2, oldColors[5]);
  }

  void updateColorsBi() {
    color[] oldColors = new color [faces.length];
    for (int i = 0; i < oldColors.length; i++)
      oldColors[i] = faces[i].c;
    this.setColor(2, oldColors[4]);
    this.setColor(3, oldColors[5]);
    this.setColor(4, oldColors[3]);
    this.setColor(5, oldColors[2]);
  }

  void updateColorsF() {
    color[] oldColors = new color [faces.length];
    for (int i = 0; i < oldColors.length; i++)
      oldColors[i] = faces[i].c;
    this.setColor(2, oldColors[4]);
    this.setColor(3, oldColors[5]);
    this.setColor(4, oldColors[3]);
    this.setColor(5, oldColors[2]);
  }

  void updateColorsFi() {
    color[] oldColors = new color [faces.length];
    for (int i = 0; i < oldColors.length; i++)
      oldColors[i] = faces[i].c;
    this.setColor(4, oldColors[2]);
    this.setColor(5, oldColors[3]);
    this.setColor(3, oldColors[4]);
    this.setColor(2, oldColors[5]);
  }

  void setColor(int index, color c) {
    this.faces[index].c = c;
  }

  void update (int x, int y, int z) {
    matrix.reset();
    matrix.translate(x, y, z);
    this.x = x;
    this.y = y;
    this.z = z;
  }

  void highlight() {
    switch(""+x+y+z) {
    case "-1-11" : // Cube A
      faces[0] = new Face(new PVector(0, 0, 0.25), highlightColor); 
      faces[2] = new Face(new PVector(0, f, 0.25), highlightColor);  
      faces[4] = new Face(new PVector(f, 0, -0.25), highlightColor);
      break;
    case "1-11" : // Cube B
      faces[0] = new Face(new PVector(0, 0, 0.25), highlightColor); 
      faces[2] = new Face(new PVector(0, f, 0.25), highlightColor);  
      faces[5] = new Face(new PVector(f, 0, 0.25), highlightColor);
      break;
    case "-1-1-1" : // Cube C
      faces[1] = new Face(new PVector(0, 0, -0.25), highlightColor); 
      faces[2] = new Face(new PVector(0, f, 0.25), highlightColor);  
      faces[4] = new Face(new PVector(f, 0, -0.25), highlightColor);
      break;
    case "1-1-1" :   // Cube D
      faces[1] = new Face(new PVector(0, 0, -0.25), highlightColor); 
      faces[2] = new Face(new PVector(0, f, 0.25), highlightColor);
      faces[5] = new Face(new PVector(f, 0, 0.25), highlightColor);
      break;
    case "-111" : // Cube E
      faces[0] = new Face(new PVector(0, 0, 0.25), highlightColor); 
      faces[3] = new Face(new PVector(0, f, -0.25), highlightColor);  
      faces[4] = new Face(new PVector(f, 0, -0.25), highlightColor);
      break;
    case "111" : // Cube F
      faces[0] = new Face(new PVector(0, 0, 0.25), highlightColor); 
      faces[3] = new Face(new PVector(0, f, -0.25), highlightColor);  
      faces[5] = new Face(new PVector(f, 0, 0.25), highlightColor);
      break;
    case "-11-1" : // Cube G
      faces[1] = new Face(new PVector(0, 0, -0.25), highlightColor); 
      faces[3] = new Face(new PVector(0, f, -0.25), highlightColor);  
      faces[4] = new Face(new PVector(f, 0, -0.25), highlightColor);
      break;
    case "11-1" : // Cube H
      faces[1] = new Face(new PVector(0, 0, -0.25), highlightColor); 
      faces[3] = new Face(new PVector(0, f, -0.25), highlightColor);  
      faces[5] = new Face(new PVector(f, 0, 0.25), highlightColor);
      break;
    }
  }

  void unhighlight() {
    switch(""+x+y+z) {
    case "-1-11" : // Cube A
      faces[0] = new Face(new PVector(0, 0, 0.25), baseColor); 
      faces[2] = new Face(new PVector(0, f, 0.25), baseColor);  
      faces[4] = new Face(new PVector(f, 0, -0.25), baseColor);
      break;
    case "1-11" : // Cube B
      faces[0] = new Face(new PVector(0, 0, 0.25), baseColor); 
      faces[2] = new Face(new PVector(0, f, 0.25), baseColor);  
      faces[5] = new Face(new PVector(f, 0, 0.25), baseColor);
      break;
    case "-1-1-1" : // Cube C
      faces[1] = new Face(new PVector(0, 0, -0.25), baseColor); 
      faces[2] = new Face(new PVector(0, f, 0.25), baseColor);  
      faces[4] = new Face(new PVector(f, 0, -0.25), baseColor);
      break;
    case "1-1-1" :   // Cube D
      faces[1] = new Face(new PVector(0, 0, -0.25), baseColor); 
      faces[2] = new Face(new PVector(0, f, 0.25), baseColor);
      faces[5] = new Face(new PVector(f, 0, 0.25), baseColor);
      break;
    case "-111" : // Cube E
      faces[0] = new Face(new PVector(0, 0, 0.25), baseColor); 
      faces[3] = new Face(new PVector(0, f, -0.25), baseColor);  
      faces[4] = new Face(new PVector(f, 0, -0.25), baseColor);
      break;
    case "111" : // Cube F
      faces[0] = new Face(new PVector(0, 0, 0.25), baseColor); 
      faces[3] = new Face(new PVector(0, f, -0.25), baseColor);  
      faces[5] = new Face(new PVector(f, 0, 0.25), baseColor);
      break;
    case "-11-1" : // Cube G
      faces[1] = new Face(new PVector(0, 0, -0.25), baseColor); 
      faces[3] = new Face(new PVector(0, f, -0.25), baseColor);  
      faces[4] = new Face(new PVector(f, 0, -0.25), baseColor);
      break;
    case "11-1" : // Cube H
      faces[1] = new Face(new PVector(0, 0, -0.25), baseColor); 
      faces[3] = new Face(new PVector(0, f, -0.25), baseColor);  
      faces[5] = new Face(new PVector(f, 0, 0.25), baseColor);
      break;
    }
  }

  void highlight (int j) {
    switch(""+x+y+z) {
    case "-1-11" : // Cube A
      if (j == 1)
        faces[0] = new Face(new PVector(0, 0, 0.25), highlightColor);
      if (j == 0)
        faces[2] = new Face(new PVector(0, f, 0.25), highlightColor);  
      if (j == 2)
        faces[4] = new Face(new PVector(f, 0, -0.25), highlightColor);
      break;
    case "1-11" : // Cube B
      if (j == 1)
        faces[0] = new Face(new PVector(0, 0, 0.25), highlightColor); 
      if (j == 0)
        faces[2] = new Face(new PVector(0, f, 0.25), highlightColor);  
      if (j == 2)
        faces[5] = new Face(new PVector(f, 0, 0.25), highlightColor);
      break;
    case "-1-1-1" : // Cube C
      if (j == 1)
        faces[1] = new Face(new PVector(0, 0, -0.25), highlightColor); 
      if (j == 0)
        faces[2] = new Face(new PVector(0, f, 0.25), highlightColor);  
      if (j == 2)
        faces[4] = new Face(new PVector(f, 0, -0.25), highlightColor);
      break;
    case "1-1-1" :   // Cube D
      if (j == 1)
        faces[1] = new Face(new PVector(0, 0, -0.25), highlightColor); 
      if (j == 0)
        faces[2] = new Face(new PVector(0, f, 0.25), highlightColor);
      if (j == 2)
        faces[5] = new Face(new PVector(f, 0, 0.25), highlightColor);
      break;
    case "-111" : // Cube E
      if (j == 1)
        faces[0] = new Face(new PVector(0, 0, 0.25), highlightColor);
      if (j == 0)
        faces[3] = new Face(new PVector(0, f, -0.25), highlightColor);  
      if (j == 2)
        faces[4] = new Face(new PVector(f, 0, -0.25), highlightColor);
      break;
    case "111" : // Cube F
      if (j == 1)
        faces[0] = new Face(new PVector(0, 0, 0.25), highlightColor); 
      if (j == 0)
        faces[3] = new Face(new PVector(0, f, -0.25), highlightColor);  
      if (j == 2)
        faces[5] = new Face(new PVector(f, 0, 0.25), highlightColor);
      break;
    case "-11-1" : // Cube G
      if (j == 1)
        faces[1] = new Face(new PVector(0, 0, -0.25), highlightColor); 
      if (j == 0)
        faces[3] = new Face(new PVector(0, f, -0.25), highlightColor);  
      if (j == 2)
        faces[4] = new Face(new PVector(f, 0, -0.25), highlightColor);
      break;
    case "11-1" : // Cube H
      if (j == 1)
        faces[1] = new Face(new PVector(0, 0, -0.25), highlightColor); 
      if (j == 0)
        faces[3] = new Face(new PVector(0, f, -0.25), highlightColor);  
      if (j == 2)
        faces[5] = new Face(new PVector(f, 0, 0.25), highlightColor);
      break;
    }
  }

  void show () {
    fill (100);
    stroke(0);
    strokeWeight(0.15);
    pushMatrix();
    applyMatrix(matrix);
    box(2);
    for (Face f : faces)
      f.show();
    popMatrix();
  }
}


boolean debug = false, debugReverse = false, autoDebug = true;
int debugCount = -1, debugInt = 0;
Move debugMove;
float textWidth = 0, highlightX, highlightY, debugTextSize = 20;

void debugShow (String s) {
  cam.beginHUD();
  fill(white);
  text(s, 200, 920);
  cam.endHUD();
}

void showDebugCount() {
  cam.beginHUD();
  fill(white);
  text(""+debugCount, 100, 140);
  cam.endHUD();
}

void debugSetup() {
  input.solve();
  input.optimizeAlgorithmList();
  solveAlgorithm = input.listOfAlgorithms;
  for (String s : solveAlgorithm)
    debugSolveAlgorithm.add(s);
}

float algorithmX, algorihtmY, algorithmWidth, algorithmHeight;

void debug() {
  if (showDebugFlag)
    displayDebugFlag();
  algorithmX = 0.05 * displayWidth; 
  algorihtmY = 0.825 * displayHeight; 
  algorithmWidth = 0.85 * displayWidth; 
  algorithmHeight = 0.2 * displayHeight;
  debug = true;
  textSize(debugTextSize);
  debug_Fast();
  autoDebug();  
  showSolveInfo();
  //debug_Slow();
}

int numOfSuccessfulSolves = 0;
boolean autoSolve = true;

int startNextSolveCount = 0;
boolean startNextSolve = true;

final int autoDebugWaitTime = 100;
double totalMoves = 0;

void autoDebug() {
  if (startNextSolve)
    startNextSolveCount++;
  if (!autoDebug || executing || startNextSolveCount < autoDebugWaitTime)
    return;
  if (autoSolve) {
    if (!autoDebug_verifySolve)
      solve();
  } else 
  scramble();
}

void showSolveInfo() {
  if (numOfSuccessfulSolves == 0)
    return;
  float x = displayWidth - (counterCenterX + (counterDiameter / 2.0)), s = 0.0937 * displayWidth, y = 0.4 * (displayHeight - s);
  cam.beginHUD();
  text ("Successful Solves: "+numOfSuccessfulSolves, x, y);
  double avg = totalMoves / numOfSuccessfulSolves;
  text ("Average Solve Length: " + (avg), x, y + textHeight(""));
  cam.endHUD();
}

void debug_Fast() {
  multiplier = Float.MAX_VALUE;
  text("Scramble Algorithm: "+scrambleAlgorithm, algorithmX, algorihtmY, algorithmWidth, algorithmHeight);
}

void debug_Slow() {
  highlightX = algorithmX;
  highlightY = algorihtmY;
  highlightMove();
  fill(white);
  text("Solve Algorithm: "+debugSolveAlgorithm+ " == (" + debugSolveAlgorithm.size()+ ")", algorithmX, algorihtmY, algorithmWidth, algorithmHeight);
  if (debugCount == -1)
    return;
  debugCounter();
  debugShowMove();
}

void highlightMove() {
  if (debugCount == -1)
    return;
  textSize(debugTextSize);
  textWidth = textWidth("Solve Algorithm:  ");
  for (int i = 0; i < debugCount; i++)
    textWidth += textWidth(debugSolveAlgorithm.get(i) + ", ");
  noStroke();
  fill(black);
  rect(highlightX + textWidth, highlightY, 1.10 * textWidth("   "), textHeight(""));
}

void debugMove() {
  if (debugCount < 0 || debugCount > debugSolveAlgorithm.size() - 1)
    return;
  Move m = defaultMove;
  switch(debugSolveAlgorithm.get(debugCount)) {
  case F_ :
    m = F;
    break;
  case Fi_ :
    m = Fi;
    break;
  case L_ :
    m = L;
    break;
  case Li_ :
    m = Li;
    break;
  case R_ :
    m = R;
    break;
  case Ri_ :
    m = Ri;
    break;
  case B_ :
    m = B;
    break;
  case Bi_ :
    m = Bi;
    break;
  case D_ :
    m = D;
    break;
  case Di_ :
    m = Di;
    break;
  case U_ :
    m = U;
    break;
  case Ui_ :
    m = Ui;
    break;
  }
  if (debugReverse) {
    m.inverse().start();
    debugCount--;
    m = m.inverse();
  } else {
    if (input.isSolved())
      return;
    m.start();
  }
  debugMove = m;
}

void debugCounter() {
  float x = 0.842 * displayWidth, y = 0.5 * displayHeight, d = 0.117 * displayWidth;
  counterDiameter = d;   
  counterCenterX = x;
  fill(black);
  circle(x, y, d);
  String moveNum = "" + (debugCount + 1);
  setCounterTextSize();
  fill(white);
  text (moveNum, x - textWidth(moveNum) / 2.0, y + textHeight(maxCount) / 2.0);
}

void debugShowMove() {
  float x = displayWidth - (counterCenterX + (counterDiameter / 2.0)), s = 0.0937 * displayWidth, y = 0.5 * (displayHeight - s);
  moveBoxSideLength = s;
  fill(black);
  square(x, y, s);
  fill(white);
  setMoveTextSize();
  String moveToShow = debugMove.toString();
  text (moveToShow, x + (s - textWidth(moveToShow)) / 2.0, y + 1.35 * (s - textHeight(moveToShow)));
}

boolean showDebugFlag = false;

void showDebugFlag() {
  showDebugFlag = true;
}

void hideDebugFlag() {
  showDebugFlag = false;
}

color emerald = color(0, 255, 128);

void displayDebugFlag() {
  fill(emerald);
  circle(0.1 * displayWidth, 0.2 * displayHeight, .075 * displayWidth);
}

boolean autoDebug_verifySolve = false;
int autoDebugCount = 0;

void autoDebug_verifySolve() {
  autoDebug_verifySolve = true;
}

void checkAutoDebug() {
  if (autoDebug_verifySolve)
    autoDebugCount++;
  else
    return;
  if (autoDebugCount > autoDebugWaitTime) {
    if (input.isSolved()) {
      autoSolve = false;
      numOfSuccessfulSolves++;
    } else
      autoDebug = false;
    autoDebug_verifySolve = false;
    autoDebugCount = 0;
    totalMoves += solveLength;
  }
}


class Face {

  PVector normal;
  color c;  

  Face (PVector normal, color c) {
    this.normal = normal;
    this.c = c;
  }

  void turnZ(float angle) {
    PVector v2 = new PVector();
    v2.x = round(normal.x * cos(angle) - normal.y * sin(angle));
    v2.y = round(normal.x * sin(angle) + normal.y * cos(angle));
    v2.z = round(normal.z);
    normal = v2;
  }

  void turnY(float angle) {
    PVector v2 = new PVector();
    v2.x = round(normal.x * cos(angle) - normal.z * sin(angle));
    v2.z = round(normal.x * sin(angle) + normal.x * cos(angle));
    v2.y = round(normal.y);
    normal = v2;
  }

  void turnX(float angle) {
    PVector v2 = new PVector();
    v2.y = round(normal.y * cos(angle) - normal.z * sin(angle));
    v2.z = round(normal.y * sin(angle) + normal.z * cos(angle));
    v2.x = round(normal.x);
    normal = v2;
  }

  void show() {
    pushMatrix();
    fill(c);
    noStroke();
    rectMode(CENTER);
    if (abs(normal.y) > 0) 
      rotateX(HALF_PI);
    else if (abs(normal.x) > 0) 
      rotateY(HALF_PI);
    float k = 4.01;
    translate(k*normal.x, k*normal.y, k*normal.z);
    square(0, 0, 2);
    popMatrix();
  }
}


final int dim = 2;
Cubie[] cubies = new Cubie[(int)(Math.pow(dim, 3))];

PeasyCam cam;

Move currentMove;
Move F, U, R, L, D, B, Fi, Ui, Ri, Li, Di, Bi, defaultMove;

boolean running = false, print = true, solved = false, random_Solve = false, tryMe = false, solve = false, 
  keepCounter = false, scramble = false, goingUp = true, showCounter = false, showTitle = true, showMove = true, 
  showSolveAlert = false, showInputAlert = false, inputCube = false, executing = false, 
  highlightInputCubeButton = false, freezeCam = false, rotating = false, atHome = true, 
  waitThenSolve = false, waitThenScramble = false, goingHome = false, resetMultiplier = false, 
  showFaceNames = false, firstClick_Middle = true, camActive = false, scrambling = false, solving = false, allowKeyPressed = true;

ArrayList<Move> moves = new ArrayList<Move>();
ArrayList<Move> moveList = new ArrayList<Move>();
ArrayList<Move> scrambleAlgorithm = new ArrayList<Move>();
ArrayList<String> solveAlgorithm = new ArrayList<String>();
ArrayList<String> debugSolveAlgorithm = new ArrayList<String>();
Move[] moveSequence = {};
int counter = 0, printNum = 0, solveLength = -1;

Cube[] cubes = new Cube[8];
Cube[] initialCubes = new Cube[8];
RubiksCube_2x2 input;

float multiplier = 1;

int bgColor = 155, titleColor = 255, initialBgColor = bgColor, increment = 5, 
  width = 200, height = 50, stopWatch = 0, randomCheck = -1, counterKeep = -1, 
  counterX, counterY, solveAlert = 0, keepTimer = 0, keepTime = 300, inputAlert = 0, 
  highlightInputCube = 0, highlightInputWait = 0, highlightInputSleep = 0, highlightInputCubeCount = 0, 
  goingHomeResetCount = 0, stall = 0;

final color baseColor = color(23), white = color(255), yellow = color(255, 251, 41), blue = color (0, 40, 255), 
  green = color(1, 145, 15), red = color (255, 0, 0), purple = color(94, 0, 219), black = color(0), 
  backgroundColor = color (bgColor, 59, 30), skyBlue = color (135, 206, 235), cyan = color (0, 255, 255), 
  orange = color (242, 98, 35), pink = color(255, 0, 255), highlightColor = cyan, baseButtonColor = color (155, 15, 230);

final float origDisplayWidth = 1366, origDisplayHeight = 768;

CameraState frozenState = null;

class Move {
  float angle = 0;
  int x = 0, y = 0, z = 0, dir;
  boolean animating = false, finished = false;

  Move (int x, int y, int z, int dir) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.dir = dir;
  }

  boolean equals (Move m) {
    if (this.x == m.x && this.y == m.y && this.z == m.z && this.dir == m.dir)
      return true;
    return false;
  }

  Move opplement() {
    if (this.equals(F))
      return B;
    if (this.equals(Fi))
      return Bi;
    if (this.equals(R))
      return L;
    if (this.equals(Ri))
      return Li;
    if (this.equals(U))
      return D;
    if (this.equals(Ui))
      return Di;
    if (this.equals(D))
      return U;
    if (this.equals(Di))
      return Ui;
    if (this.equals(L))
      return R;
    if (this.equals(Li))
      return Ri;
    if (this.equals(B))
      return F;
    if (this.equals(Bi))
      return Fi;
    return defaultMove;
  }

  Move complement() {
    if (this.equals(F))
      return Bi;
    if (this.equals(Fi))
      return B;
    if (this.equals(R))
      return Li;
    if (this.equals(Ri))
      return L;
    if (this.equals(U))
      return Di;
    if (this.equals(Ui))
      return D;
    if (this.equals(D))
      return Ui;
    if (this.equals(Di))
      return U;
    if (this.equals(L))
      return Ri;
    if (this.equals(Li))
      return R;
    if (this.equals(B))
      return Fi;
    if (this.equals(Bi))
      return F;
    return defaultMove;
  }

  Move inverse() {
    if (this.equals(F))
      return Fi;
    if (this.equals(Fi))
      return F;
    if (this.equals(R))
      return Ri;
    if (this.equals(Ri))
      return R;
    if (this.equals(U))
      return Ui;
    if (this.equals(Ui))
      return U;
    if (this.equals(D))
      return Di;
    if (this.equals(Di))
      return D;
    if (this.equals(L))
      return Li;
    if (this.equals(Li))
      return L;
    if (this.equals(B))
      return Bi;
    if (this.equals(Bi))
      return B;
    return defaultMove;
  }

  void start() {
    animating = true;
  }

  String toString() {
    if (this.equals(F))
      return "F";
    if (this.equals(Fi))
      return "Fi";
    if (this.equals(R))
      return "R";
    if (this.equals(Ri))
      return "Ri";
    if (this.equals(L))
      return "L";
    if (this.equals(Li))
      return "Li";
    if (this.equals(U))
      return "U";
    if (this.equals(Ui))
      return "Ui";
    if (this.equals(D))
      return "D";
    if (this.equals(Di))
      return "Di";
    if (this.equals(B))
      return "B";
    if (this.equals(Bi))
      return "Bi";
    return null;
  }

  void update() {
    float speed = multiplier * 0.041381275;
    if (animating) 
      angle += dir * speed;
    if (abs(angle) > HALF_PI) {
      this.angle = 0;
      animating = false;
      finished = true;
      switch (""+x+y+z+dir) {
      case "0011" : 
        F();
        break;
      case "001-1" : 
        Fi();
        break;
      case "00-1-1" : 
        B();
        break;
      case "00-11" : 
        Bi();
        break;
      case "0101" : 
        D();
        break;
      case "010-1" : 
        Di();
        break;
      case "0-101" : 
        Ui();
        break;
      case "0-10-1" : 
        U();
        break;
      case "1001" : 
        R();
        break;
      case "100-1" : 
        Ri();
        break;
      case "-1001" : 
        Li();
        break;
      case "-100-1" : 
        L();
        break;
      }
    }
  }
}


void resetMultiplier () {
  resetMultiplier = true;
}

void checkResetMultiplier() {
  if (resetMultiplier)
    stall++;
  if (stall > 7) {
    stall = 0;
    multiplier = 1;
    resetMultiplier = false;
  }
}

void inputCubeUserButtonReset() {
  if (inputCube_mousePressed && !mousePressed) {
    inputCube_Unpressed = true;
    inputCube_mousePressed = false;
  }
  if (inputCubeUserButton.pressed == false)
    resetInputCube();
}

void solveCubeUserButtonReset() {
  if (input.isSolved())
    solveUserButton.pressed = false;
}

void goingHomeReset() {
  if (goingHome) {
    goingHomeResetCount++;
    if (goingHomeResetCount == 35) {
      goingHome = false;
      goingHomeResetCount = 0;
    }
  }
}

void middleButtonReset() {
  if (!mousePressed) 
    firstClick_Middle = true;
}

void cursorReset() {
  if (mouseInsideButton()) {
    noCursor();
    cubeDraw(mouseX, mouseY, 22.5);
  } else
    cursor();
}

void activateControlButtons() {
  cancel.activate();
  left.activate();
  up.activate();
  right.activate();
  down.activate();
  middle.activate();
  f.activate();
  fi.activate();
  r.activate();
  ri.activate();
  u.activate();
  ui.activate();
  l.activate();
  li.activate();
  d.activate();
  di.activate();
  b.activate();
  bi.activate();
}

void deactivateControlButtons() {
  cancel.deactivate();
  left.deactivate();
  up.deactivate();
  right.deactivate();
  down.deactivate();
  middle.deactivate();
  f.deactivate();
  fi.deactivate();
  r.deactivate();
  ri.deactivate();
  u.deactivate();
  ui.deactivate();
  l.deactivate();
  li.deactivate();
  d.deactivate();
  di.deactivate();
  b.deactivate();
  bi.deactivate();
}

void activateOptionButtons_Position () {
  pieceOption1.activate();
  pieceOption2.activate();
  pieceOption3.activate();
  pieceOption4.activate();
  pieceOption5.activate();
  pieceOption6.activate();
  pieceOption7.activate();
  pieceOption8.activate();
}

void deactivateOptionButtons_Position () {
  pieceOption1.deactivate();
  pieceOption2.deactivate();
  pieceOption3.deactivate();
  pieceOption4.deactivate();
  pieceOption5.deactivate();
  pieceOption6.deactivate();
  pieceOption7.deactivate();
  pieceOption8.deactivate();
}

void activateOptionButtons_Orientation () {
  colorOption1.activate();
  colorOption2.activate();
  colorOption3.activate();
}

void deactivateOptionButtons_Orientation () {
  colorOption1.deactivate();
  colorOption2.deactivate();
  colorOption3.deactivate();
}

void activateOptionButtons() {
  activateOptionButtons_Position();
  activateOptionButtons_Orientation();
}

void deactivateOptionButtons() {
  deactivateOptionButtons_Position();
  deactivateOptionButtons_Orientation();
}

boolean mousePressedActive = true;
int mouseActiveCounter = 0;

void resetActiveButtons() {
  if (atHome)
    Home.deactivate();
  else
    Home.activate();
  if (Controls.pressed)
    activateControlButtons();
  else
    deactivateControlButtons();
  if (inputCubeUserButton.pressed) {
    if (promptUser_Position) {
      activateOptionButtons_Position();
      deactivateOptionButtons_Orientation();
    } else {
      deactivateOptionButtons_Position();
      activateOptionButtons_Orientation();
    }
  } else {
    deactivateOptionButtons_Position();
    deactivateOptionButtons_Orientation();
    userCubeFlipped = false; 
    userCubeFlipped_Animation = false;
  }
  if (!mousePressedActive)
    if (mouseActiveCounter < 10)
      mouseActiveCounter++;
    else {
      mouseActiveCounter = 0;
      mousePressedActive = true;
    }
}

boolean resetRunning = false;
int runningResetCount = 0;

void resetRunning() {
  if (resetRunning)
    runningResetCount++;
  if (runningResetCount > 50) {
    running = false;
    runningResetCount = 0;
    resetRunning = false;
  }
}

void resetInputCube() {
  cubeOptions = new ArrayList<Cube>();
  inputCubeUserButton.pressed = false;
  cubeOptionSetup();
  positionCounter = 0;
  inputCube = false;
  promptUser_Position = true;
  selectedCube = new Cube();
  selectedColor = "";
}

boolean resetScrambling = false;
int scrambleResetCount = 0;

void resetScrambling() {
  if (resetScrambling)
    scrambleResetCount++;
  if (scrambleResetCount > 50) {
    scrambleUserButton.pressed = false;
    scrambling = false;
    scrambleResetCount = 0;
    resetScrambling = false;
  }
}

void movesReset_Running() {
  if (moves.size() > 0) {
    running = true;
    multiplier = 5;
  }
}

void runningReset_InputCube() {
  if (inputCubeUserButton.pressed) {
    running = false;
    moves = new ArrayList<Move>();
  }
}

void movesReset() {
  if (!running) 
    moves = new ArrayList<Move>();
}

void scrambleUserButtonReset() {
  if (!scrambling)
    scrambleUserButton.pressed = false;
}


boolean resetKeyPressed = false;
int resetKeyPressedCount = 0;

void allowKeyPressedReset() {
  if (resetKeyPressed)
    resetKeyPressedCount++;
  if (resetKeyPressedCount > 50) {
    allowKeyPressed = true;
    resetKeyPressedCount = 0;
    resetKeyPressed = false;
  }
}

void resetDraw() {
  inputCubeUserButtonReset();
  goingHomeReset();
  solveCubeUserButtonReset();
  middleButtonReset();
  cursorReset();
  resetActiveButtons();
  resetRunning();
  resetScrambling();
  movesReset_Running();
  runningReset_InputCube();
  movesReset();
  scrambleUserButtonReset();
  allowKeyPressedReset();
}

import java.util.ArrayList;
import java.util.Arrays;
import javax.swing.JOptionPane;

public class RubiksCube {

  static final String w = "White";
  static final String y = "Yellow";
  static final String b = "Blue";
  static final String g = "Green";
  static final String r = "Red";
  static final String p = "Purple";

  static final String WBR = "White-Blue-Red Corner";
  static final String WBP = "White-Blue-Purple Corner";
  static final String WGR = "White-Green-Red Corner";
  static final String WGP = "White-Green-Purple Corner";
  static final String YBR = "Yellow-Blue-Red Corner";
  static final String YBP = "Yellow-Blue-Purple Corner";
  static final String YGR = "Yellow-Green-Red Corner";
  static final String YGP = "Yellow-Green-Purple Corner";

  static final char A = 'A';
  static final char B = 'B';
  static final char C = 'C';
  static final char D = 'D';
  static final char E = 'E';
  static final char F = 'F';
  static final char G = 'G';
  static final char H = 'H';

  static final int one = 1;
  static final int two = 2;
  static final int three = 3;
}

public class RubiksCube_2x2 {

  private Cube a, b, c, d, e, f, g, h;
  private Cube[] Cubes = { a, b, c, d, e, f, g, h };
  private Cube[] LayerU = { a, c, d, b };
  private Cube[] LayerD = { e, f, h, g };
  private Cube[] LayerL = { a, e, g, c };
  private Cube[] LayerR = { b, d, h, f };
  private Cube[] LayerF = { a, b, f, e };
  private Cube[] LayerB = { c, g, h, d };

  private static final String layerU_positions = "ACDB";
  private static final String layerD_positions = "EFHG";
  private static final String layerL_positions = "AEGC";
  private static final String layerR_positions = "BDHF";
  private static final String layerF_positions = "ABFE";
  private static final String layerB_positions = "CGHD";

  private ArrayList<String> listOfAlgorithms = new ArrayList<String>();
  private ArrayList<String> listOfAlgorithms_original = new ArrayList<String>();
  private ArrayList<String> listOfExplanations = new ArrayList<String>();
  private ArrayList<Integer> listOfSizes = new ArrayList<Integer>();

  public void implementCube_2x2(Cube[] cubes) {
    this.a = cubes[0];
    this.b = cubes[1];
    this.c = cubes[2];
    this.d = cubes[3];
    this.e = cubes[4];
    this.f = cubes[5];
    this.g = cubes[6];
    this.h = cubes[7];
    Cube[] CUBES = { a, b, c, d, e, f, g, h };
    Cubes = CUBES;
    Cube[] LAYER_U = { a, c, d, b };
    LayerU = LAYER_U;
    Cube[] LAYER_D = { e, f, h, g };
    LayerD = LAYER_D;
    Cube[] LAYER_L = { a, e, g, c };
    LayerL = LAYER_L;
    Cube[] LAYER_R = { b, d, h, f };
    LayerR = LAYER_R;
    Cube[] LAYER_F = { a, b, f, e };
    LayerF = LAYER_F;
    Cube[] LAYER_B = { c, g, h, d };
    LayerB = LAYER_B;
  }

  public RubiksCube_2x2(Cube[] cubes) {
    implementCube_2x2(cubes);
  }

  public ArrayList<String> algorithmList() {
    return this.listOfAlgorithms;
  }

  public void update () {
    this.update(cubes);
  }

  public void update (Cube[] cubes) {
    implementCube_2x2(cubes);
  }

  public Cube[] Cubes() {
    return this.Cubes;
  }

  public Cube[] LayerU() {
    return LayerU;
  }

  public void reImplementCube_2x2(Cube[] layer) {
    switch (layer[3].position()) {
    case 'B':
      this.a = layer[0];
      this.c = layer[1];
      this.d = layer[2];
      this.b = layer[3];
      break;
    case 'G':
      this.e = layer[0];
      this.f = layer[1];
      this.h = layer[2];
      this.g = layer[3];
      break;
    case 'C':
      this.a = layer[0];
      this.e = layer[1];
      this.g = layer[2];
      this.c = layer[3];
      break;
    case 'F':
      this.b = layer[0];
      this.d = layer[1];
      this.h = layer[2];
      this.f = layer[3];
      break;
    case 'E':
      this.a = layer[0];
      this.b = layer[1];
      this.f = layer[2];
      this.e = layer[3];
      break;
    case 'D':
      this.c = layer[0];
      this.g = layer[1];
      this.h = layer[2];
      this.d = layer[3];
      break;
    }
    Cube[] reImplementedArray = { a, b, c, d, e, f, g, h };
    this.implementCube_2x2(reImplementedArray);
  }

  public void U() {
    Cube[] temp = LayerU.clone();
    for (int i = 0; i < temp.length; i++) {
      LayerU[i] = temp[clockwise[i]];
      LayerU[i].changePositionTo(layerU_positions.charAt(i));
    }
    this.reImplementCube_2x2(LayerU);
    listOfAlgorithms.add(U_);
  }

  public void U(int n) {
    for (int i = 0; i < n; i++)
      this.U();
  }

  public void Ui() {
    Cube[] temp = LayerU.clone();
    for (int i = 0; i < temp.length; i++) {
      LayerU[i] = temp[anti_clockwise[i]];
      LayerU[i].changePositionTo(layerU_positions.charAt(i));
    }
    this.reImplementCube_2x2(LayerU);
    listOfAlgorithms.add(Ui_);
  }

  public void Ui(int n) {
    for (int i = 0; i < n; i++)
      this.Ui();
  }

  public Cube[] LayerD() {
    return LayerD;
  }

  public void D() {
    Cube[] temp = LayerD.clone();
    for (int i = 0; i < temp.length; i++) {
      LayerD[i] = temp[clockwise[i]];
      LayerD[i].changePositionTo(layerD_positions.charAt(i));
    }
    this.reImplementCube_2x2(LayerD);
    listOfAlgorithms.add(D_);
  }

  public void D(int n) {
    for (int i = 0; i < n; i++)
      this.D();
  }

  public void Di() {
    Cube[] temp = LayerD.clone();
    for (int i = 0; i < temp.length; i++) {
      LayerD[i] = temp[anti_clockwise[i]];
      LayerD[i].changePositionTo(layerD_positions.charAt(i));
    }
    this.reImplementCube_2x2(LayerD);
    listOfAlgorithms.add(Di_);
  }

  public void Di(int n) {
    for (int i = 0; i < n; i++)
      this.Di();
  }

  public Cube[] LayerL() {
    return LayerL;
  }

  public void L() {
    Cube[] temp = LayerL.clone();
    for (int i = 0; i < temp.length; i++) {
      LayerL[i] = temp[clockwise[i]];
      LayerL[i].changeOrientationTo(LayerL[i].conjugateOrientation(2));
      LayerL[i].changePositionTo(layerL_positions.charAt(i));
    }
    this.reImplementCube_2x2(LayerL);
    listOfAlgorithms.add(L_);
  }

  public void L(int n) {
    for (int i = 0; i < n; i++)
      this.L();
  }

  public void adjustAlgorithmListForInversion() {
    for (int i = 0; i < 3; i++)
      listOfAlgorithms.remove(listOfAlgorithms.size() - 1);
  }

  public void adjustAlgorithmListForRedundance(int index) {
    for (int i = 0; i < 3; i++)
      listOfAlgorithms.remove(index + 1);
  }

  public String optimizedAlgorithmList() {
    optimizeAlgorithmList();
    String optimizedAlgorithmList = "";
    for (int i = 0; i < listOfAlgorithms.size(); i++) {
      optimizedAlgorithmList += listOfAlgorithms.get(i);
      if (listOfAlgorithms.get(i).length() == 1)
        optimizedAlgorithmList += " ";
      if (i == listOfAlgorithms.size() - 1)
        optimizedAlgorithmList += " = ";
      else
        optimizedAlgorithmList += " + ";
      if ((i + 1) % 10 == 0)
        optimizedAlgorithmList += "\n";
    }
    optimizedAlgorithmList += "[" + listOfAlgorithms.size() + "]";
    return optimizedAlgorithmList;
  }

  public boolean algorithmListIsOptimized() {
    for (int i = 0; i < listOfAlgorithms.size() - 1; i++)
      if (listOfAlgorithms.get(i).equals(inverseOf(listOfAlgorithms.get(i + 1))))
        return false;
    for (int i = 0; i < listOfAlgorithms.size() - 2; i++)
      if (listOfAlgorithms.get(i).equals(listOfAlgorithms.get(i + 1))
        && listOfAlgorithms.get(i + 1).equals(listOfAlgorithms.get(i + 2)))
        return false;
    return true;
  }

  public void optimizeAlgorithmList() {
    if (listOfAlgorithms_original.size() == 0)
      for (int i = 0; i < listOfAlgorithms.size(); i++)
        listOfAlgorithms_original.add(listOfAlgorithms.get(i));
    while (algorithmListIsOptimized() == false) {
      for (int i = 0; i < listOfAlgorithms.size() - 1; i++)
        if (listOfAlgorithms.get(i).equals(inverseOf(listOfAlgorithms.get(i + 1)))) {
          listOfAlgorithms.remove(i + 1);
          listOfAlgorithms.remove(i--);
        }
      for (int i = 0; i < listOfAlgorithms.size() - 2; i++)
        if (listOfAlgorithms.get(i).equals(listOfAlgorithms.get(i + 1))
          && listOfAlgorithms.get(i + 1).equals(listOfAlgorithms.get(i + 2))) {
          listOfAlgorithms.add(i, inverseOf(listOfAlgorithms.get(i)));
          adjustAlgorithmListForRedundance(i);
        }
    }
    if (listOfAlgorithms.size() >= 2 && listOfAlgorithms.get(listOfAlgorithms.size() - 1)
      .equals(complementOf(listOfAlgorithms.get(listOfAlgorithms.size() - 2))))
      for (int i = 0; i < 2; i++)
        listOfAlgorithms.remove(listOfAlgorithms.size() - 1);
    if (listOfAlgorithms.size() >= 3 && listOfAlgorithms.get(listOfAlgorithms.size() - 3).equals(Di)
      && listOfAlgorithms.get(listOfAlgorithms.size() - 2).equals(U)
      && listOfAlgorithms.get(listOfAlgorithms.size() - 1).equals(U)) {
      listOfAlgorithms.remove(listOfAlgorithms.size() - 2);
      listOfAlgorithms.remove(listOfAlgorithms.size() - 2);
    }
  }

  public void Li() {
    this.L(3);
    adjustAlgorithmListForInversion();
    listOfAlgorithms.add(Li_);
  }

  public void Li(int n) {
    for (int i = 0; i < n; i++)
      this.Li();
  }

  public Cube[] LayerR() {
    return LayerR;
  }

  public void R() {
    Cube[] temp = LayerR.clone();
    for (int i = 0; i < temp.length; i++) {
      LayerR[i] = temp[clockwise[i]];
      LayerR[i].changeOrientationTo(LayerR[i].conjugateOrientation(2));
      LayerR[i].changePositionTo(layerR_positions.charAt(i));
    }
    this.reImplementCube_2x2(LayerR);
    listOfAlgorithms.add(R_);
  }

  public void R(int n) {
    for (int i = 0; i < n; i++)
      this.R();
  }

  public void Ri() {
    this.R(3);
    adjustAlgorithmListForInversion();
    listOfAlgorithms.add(Ri_);
  }

  public void Ri(int n) {
    for (int i = 0; i < n; i++)
      this.Ri();
  }

  public Cube[] LayerF() {
    return LayerF;
  }

  public void F() {
    Cube[] temp = LayerF.clone();
    for (int i = 0; i < temp.length; i++) {
      LayerF[i] = temp[clockwise[i]];
      LayerF[i].changeOrientationTo(LayerF[i].conjugateOrientation(1));
      LayerF[i].changePositionTo(layerF_positions.charAt(i));
    }
    this.reImplementCube_2x2(LayerF);
    listOfAlgorithms.add(F_);
  }

  public void F(int n) {
    for (int i = 0; i < n; i++)
      this.F();
  }

  public void Fi() {
    this.F(3);
    adjustAlgorithmListForInversion();
    listOfAlgorithms.add(Fi_);
  }

  public void Fi(int n) {
    for (int i = 0; i < n; i++)
      this.Fi();
  }

  public Cube[] LayerB() {
    return LayerB;
  }

  public void B() {
    Cube[] temp = LayerB.clone();
    for (int i = 0; i < temp.length; i++) {
      LayerB[i] = temp[clockwise[i]];
      LayerB[i].changeOrientationTo(LayerB[i].conjugateOrientation(1));
      LayerB[i].changePositionTo(layerB_positions.charAt(i));
    }
    this.reImplementCube_2x2(LayerB);
    listOfAlgorithms.add(B_);
  }

  public void B(int n) {
    for (int i = 0; i < n; i++)
      this.B();
  }

  public void Bi() {
    this.B(3);
    adjustAlgorithmListForInversion();
    listOfAlgorithms.add(Bi_);
  }

  public void Bi(int n) {
    for (int i = 0; i < n; i++)
      this.Bi();
  }

  public boolean faceU_isSolved() {
    for (int i = 0; i < LayerU.length - 1; i++)
      if (LayerU[i].faceColors()[0].equals(LayerU[i + 1].faceColors()[0]) == false)
        return false;
    return true;
  }

  public boolean faceD_isSolved() {
    for (int i = 0; i < LayerD.length - 1; i++)
      if (LayerD[i].faceColors()[0].equals(LayerD[i + 1].faceColors()[0]) == false)
        return false;
    return true;
  }

  public boolean faceR_isSolved() {
    for (int i = 0; i < LayerR.length - 1; i++)
      if (LayerR[i].faceColors()[2].equals(LayerR[i + 1].faceColors()[2]) == false)
        return false;
    return true;
  }

  public boolean faceL_isSolved() {
    for (int i = 0; i < LayerL.length - 1; i++)
      if (LayerL[i].faceColors()[2].equals(LayerL[i + 1].faceColors()[2]) == false)
        return false;
    return true;
  }

  public boolean faceF_isSolved() {
    for (int i = 0; i < LayerF.length - 1; i++)
      if (LayerF[i].faceColors()[1].equals(LayerF[i + 1].faceColors()[1]) == false)
        return false;
    return true;
  }

  public boolean faceB_isSolved() {
    for (int i = 0; i < LayerB.length - 1; i++)
      if (LayerB[i].faceColors()[1].equals(LayerB[i + 1].faceColors()[1]) == false)
        return false;
    return true;
  }

  public boolean isSolved() {
    if (this.faceU_isSolved() && this.faceD_isSolved() && this.faceL_isSolved() && this.faceR_isSolved()
      && this.faceF_isSolved() && this.faceB_isSolved())
      return true;
    return false;
  }

  public String toString() {
    return string(this.Cubes);
  }

  public void displayDescription() {
    System.out.println(this.Description());
  }

  public void display(Cube[] cubeArr) {
    System.out.println(Arrays.toString(cubeArr));
  }

  public String Description() {
    String string = "";
    for (int i = 0; i < 8; i++) {
      string += "Position " + cubePositionNames.substring(i, i + 1) + ": "
        + orientationInfo(this.Cubes()[i]) + "\n\n";
    }
    return string;
  }

  public void displayDescription(Cube[] layer) {
    System.out.println(this.Description(layer));
  }

  public String Description(Cube[] layer) {
    String string = "";
    for (int i = 0; i < layer.length; i++) {
      string += "Position " + layer[i].position() + ": " + orientationInfo(layer[i])
        + "\n\n";
    }
    return string;
  }

  public int numOfCubesWithWhiteOnUface() {
    int numOfCubesWithWhiteOnUface = 0;
    for (Cube x : this.whiteCubes())
      if (x.faceColors()[0].equals(RubiksCube.w) && x.isInUlayer())
        numOfCubesWithWhiteOnUface++;
    return numOfCubesWithWhiteOnUface;
  }

  public int numOfCubesWithWhiteOnDface() {
    int numOfCubesWithWhiteOnDface = 0;
    for (Cube x : this.whiteCubes())
      if (x.faceColors()[0].equals(RubiksCube.w) && x.isInDlayer())
        numOfCubesWithWhiteOnDface++;
    return numOfCubesWithWhiteOnDface;
  }

  public boolean first2WhiteCubesAreInCorrectPosition() {
    switch ("" + this.cubesWithWhiteOnUface()[0].position() + this.cubesWithWhiteOnUface()[1].position()) {
    case "AB":
    case "BA":
    case "CD":
    case "DC":
      if (this.cubesWithWhiteOnUface()[0].faceColors()[1].equals(this.cubesWithWhiteOnUface()[1].faceColors()[1]))
        return true;
      break;
    case "AC":
    case "CA":
    case "BD":
    case "DB":
      if (this.cubesWithWhiteOnUface()[0].faceColors()[2].equals(this.cubesWithWhiteOnUface()[1].faceColors()[2]))
        return true;
      break;
    case "AD":
    case "DA":
    case "BC":
    case "CB":
      if (this.cubesWithWhiteOnUface()[0].faceColors()[1]
        .equals(conjugateColorOf(this.cubesWithWhiteOnUface()[1].faceColors()[1])))
        return true;
      break;
    }
    return false;
  }

  public int orientationOfFirst2WhiteCubes() {
    switch ("" + this.cubesWithWhiteOnUface()[0].position() + this.cubesWithWhiteOnUface()[1].position()) {
    case "AB":
    case "BA":
    case "AC":
    case "CA":
    case "BD":
    case "DB":
    case "CD":
    case "DC":
      if (this.cubesWithWhiteOnUface()[0].faceColors()[2].equals(this.cubesWithWhiteOnUface()[1].faceColors()[2]))
        return 1;
      return 2;
    case "AD":
    case "DA":
    case "BC":
    case "CB":
      if (this.cubesWithWhiteOnUface()[0].faceColors()[1]
        .equals((this.cubesWithWhiteOnUface()[1].faceColors()[2])))
        return 3;
    }
    return 4;
  }

  public void algorithm_ProperlyPositionFirst2WhiteCubes() {
    if (this.numOfCubesWithWhiteOnUface() < 2)
      return;
    switch ("" + this.cubesWithWhiteOnUface()[0].position() + this.cubesWithWhiteOnUface()[1].position()) {
    case "AC":
      this.Ui();
      break;
    case "BC":
      this.U();
      break;
    case "BD":
      this.U();
      break;
    case "CD":
      this.U(2);
      break;
    }
    if (this.orientationOfFirst2WhiteCubes() == 1) {
      this.Ri();
      this.Ui(2);
      this.Di();
      this.Ri();
      this.D();
      this.R();
    } else if (this.orientationOfFirst2WhiteCubes() == 2) {
      this.Ri();
      this.U();
      this.R();
    } else if (this.orientationOfFirst2WhiteCubes() == 3) {
      this.L();
      this.U();
      this.Li();
    } else if (this.orientationOfFirst2WhiteCubes() == 4) {
      this.Fi();
      this.Ui();
      this.F();
    }
    listOfExplanations.add("Properly orient the two white cubes on the U face.");
    listOfSizes.add(listOfAlgorithms.size());
  }

  public void algorithm_OneCubeWithWhiteOnUface() {
    if (this.numOfCubesWithWhiteOnUface() != 1)
      return;
    int check = 0;
    while (check == 0) {
      check = 1;
      if (this.cubesWithWhiteOnUface()[0].isInLlayer() && this.cubesWithWhiteOnUface()[0].isInFlayer()) {
        if (this.cubesWithWhiteOnRlayer_excludingRface().length > 0)
          if (this.cubesWithWhiteOnRlayer_excludingRface()[0].faceColors()[0].equals(RubiksCube.w))
            this.R(2);
          else if (this.cubesWithWhiteOnRlayer_excludingRface()[0].isInFlayer())
            this.R();
          else
            this.Ri();
        else if (this.cubesWithWhiteOnBlayer_excludingBface().length > 0)
          if (this.cubesWithWhiteOnBlayer_excludingBface()[0].faceColors()[0].equals(RubiksCube.w))
            this.B(2);
          else if (this.cubesWithWhiteOnBlayer_excludingBface()[0].isInRlayer())
            this.B();
          else
            this.Bi();
        else {
          this.Ui();
          check = 0;
        }
      } else if (this.cubesWithWhiteOnUface()[0].isInRlayer() && this.cubesWithWhiteOnUface()[0].isInFlayer()) {
        if (this.cubesWithWhiteOnLlayer_excludingLface().length > 0)
          if (this.cubesWithWhiteOnLlayer_excludingLface()[0].faceColors()[0].equals(RubiksCube.w))
            this.L(2);
          else if (this.cubesWithWhiteOnLlayer_excludingLface()[0].isInBlayer())
            this.L();
          else {
            this.Li();
          } else if (this.cubesWithWhiteOnBlayer_excludingBface().length > 0)
          if (this.cubesWithWhiteOnBlayer_excludingBface()[0].faceColors()[0].equals(RubiksCube.w))
            this.B(2);
          else if (this.cubesWithWhiteOnBlayer_excludingBface()[0].isInRlayer())
            this.B();
          else
            this.Bi();
        else {
          this.Ui();
          check = 0;
        }
      } else if (this.cubesWithWhiteOnUface()[0].isInLlayer() && this.cubesWithWhiteOnUface()[0].isInBlayer()) {
        if (this.cubesWithWhiteOnRlayer_excludingRface().length > 0)
          if (this.cubesWithWhiteOnRlayer_excludingRface()[0].faceColors()[0].equals(RubiksCube.w))
            this.R(2);
          else if (this.cubesWithWhiteOnRlayer_excludingRface()[0].isInFlayer())
            this.R();
          else
            this.Ri();
        else if (this.cubesWithWhiteOnFlayer_excludingFface().length > 0)
          if (this.cubesWithWhiteOnFlayer_excludingFface()[0].faceColors()[0].equals(RubiksCube.w))
            this.F(2);
          else if (this.cubesWithWhiteOnFlayer_excludingFface()[0].isInLlayer())
            this.F();
          else
            this.Fi();
        else {
          this.Ui();
          check = 0;
        }
      } else if (this.cubesWithWhiteOnUface()[0].isInRlayer() && this.cubesWithWhiteOnUface()[0].isInBlayer()) {
        if (this.cubesWithWhiteOnLlayer_excludingLface().length > 0)
          if (this.cubesWithWhiteOnLlayer_excludingLface()[0].faceColors()[0].equals(RubiksCube.w))
            this.L(2);
          else if (this.cubesWithWhiteOnLlayer_excludingLface()[0].isInBlayer())
            this.L();
          else {
            this.Li();
          } else if (this.cubesWithWhiteOnFlayer_excludingFface().length > 0) {
          if (this.cubesWithWhiteOnFlayer_excludingFface()[0].faceColors()[0].equals(RubiksCube.w))
            this.F(2);
          else if (this.cubesWithWhiteOnFlayer_excludingFface()[0].isInLlayer()) {
            this.F();
          } else
            this.Fi();
        } else {
          this.Ui();
          check = 0;
        }
      }
    }
    listOfExplanations.add("Bring another white cube onto the U face.");
    listOfSizes.add(listOfAlgorithms.size());
  }

  public void algorithm_InsertCubeAtPosEintoPosA() {
    this.D();
    this.L();
    this.Di();
    this.Li();
  }

  public void algorithm_InsertCubeAtPosFintoPosB() {
    this.Di();
    this.Ri();
    this.D();
    this.R();
  }

  public boolean BlayerContainsWhite() {
    if (this.cubeC().containsWhite())
      return true;
    if (this.cubeD().containsWhite())
      return true;
    if (this.cubeG().containsWhite())
      return true;
    if (this.cubeH().containsWhite())
      return true;
    return false;
  }

  public boolean DlayerContainsWhite() {
    if (this.cubeE().containsWhite())
      return true;
    if (this.cubeF().containsWhite())
      return true;
    if (this.cubeG().containsWhite())
      return true;
    if (this.cubeH().containsWhite())
      return true;
    return false;
  }

  public void algorithm_TwoCubesWithWhiteOnUface_InCorrectPosition() { 
    if (this.numOfCubesWithWhiteOnUface() != 2)
      return;

    boolean linear = false;
    boolean diagonal = false;

    if (this.cubesWithWhiteOnUface()[0].isInLlayer() && this.cubesWithWhiteOnUface()[1].isInLlayer()) {
      this.Ui();
    } else if (this.cubesWithWhiteOnUface()[0].isInRlayer() && this.cubesWithWhiteOnUface()[1].isInRlayer()) {
      this.U();
    } else if (this.cubesWithWhiteOnUface()[0].isInBlayer() && this.cubesWithWhiteOnUface()[1].isInBlayer()) {
      this.U(2);
    }

    if (this.cubesWithWhiteOnUface()[0].isInFlayer() && this.cubesWithWhiteOnUface()[1].isInFlayer())       
      linear = true;
    else
      diagonal = true;

    if (linear) {
      if (this.BlayerContainsWhite() == false)
        this.D(2);
      if (this.cubesWithWhiteOnBlayer_excludingBface().length > 0) 
        if (this.cubesWithWhiteOnBlayer_excludingBface()[0].faceColors()[0].equals(RubiksCube.w)) 
          this.B(2);
        else if (this.cubesWithWhiteOnBlayer_excludingBface()[0].isInLlayer())
          this.Bi();
        else
          this.B();
      else {
        if (this.cubeC().containsWhite()) {
          this.Li();
          this.D();
          this.L();
        } else if (this.cubeD().containsWhite()) {
          this.R();
          this.Di();
          this.Ri();
        }  
        if (this.DlayerContainsWhite()) {
          if (this.cubeG().faceColors()[1].equals(RubiksCube.w)) {
            this.Di();
            this.Li();
            this.D();
            this.L();
          } else if (this.cubeH().faceColors()[1].equals(RubiksCube.w)) {
            this.D();
            this.R();
            this.Di();
            this.Ri();
          }
        }
      }
    }

    if (diagonal) {
      if (this.cubesWithWhiteOnDlayer_excludingDface().length == 0) {
        if (this.cubesWithWhiteOnDface().length == 0) {
          while ((this.cubeA().faceColors()[1].equals(RubiksCube.w) || 
            this.cubeB().faceColors()[1].equals(RubiksCube.w)) == false) 
            this.U();
          if (this.cubeA().faceColors()[1].equals(RubiksCube.w)) {
            this.L();
            this.Di();
            this.Li();
            while ((this.cubeB().faceColors()[1].equals(this.cubeE().faceColors()[0]) && 
              this.cubeC().faceColors()[2].equals(this.cubeE().faceColors()[2]) == false)) 
              this.U();
            this.algorithm_InsertCubeAtPosEintoPosA();
          } else if (this.cubeB().faceColors()[1].equals(RubiksCube.w)) {
            this.Ri();
            this.D();
            this.R();
            while ((this.cubeA().faceColors()[1].equals(this.cubeF().faceColors()[0]) && 
              this.cubeD().faceColors()[2].equals(this.cubeF().faceColors()[2]) == false)) 
              this.Ui();
            this.algorithm_InsertCubeAtPosFintoPosB();
          }
        } else {
          if (this.cubeA().faceColors()[0].equals(RubiksCube.w) == false)
            this.U();
          if (this.cubesWithWhiteOnDface().length > 0)
            if (this.cubesWithWhiteOnDface()[0].position() == 'E')
              this.Di();
            else if (this.cubesWithWhiteOnDface()[0].position() == 'F') 
              this.Di(2);
            else if (this.cubesWithWhiteOnDface()[0].position() == 'H')
              this.D();
          if (this.cubeG().faceColors()[0].equals(RubiksCube.w)) {
            this.Ri();
            this.Di();
            this.R();
          }
          while ((this.cubeB().containsWhite() && this.cubeB().faceColors()[1].equals(this.cubeF().faceColors()[0])) 
            && this.cubeB().faceColors()[2].equals(this.cubeF().faceColors()[2]) == false)
            this.Ui();
          this.algorithm_InsertCubeAtPosFintoPosB();
        }
      } else if (this.cubesWithWhiteOnDlayer_excludingDface().length > 0) {
        while ((this.cubesWithWhiteOnDlayer_excludingDface()[0].faceColors()[1].equals(RubiksCube.w) && 
          this.cubesWithWhiteOnDlayer_excludingDface()[0].isInFlayer()) == false)
          this.D();
        if (this.cubeE().faceColors()[1].equals(RubiksCube.w)) {
          while ((this.cubeA().containsWhite() == false && this.cubeB().faceColors()[1].equals(this.cubeE().faceColors()[0]) 
            && this.cubeC().faceColors()[2].equals(this.cubeE().faceColors()[2])) == false)
            this.U();
          this.algorithm_InsertCubeAtPosEintoPosA();
        } else if (this.cubeF().faceColors()[1].equals(RubiksCube.w)) {
          while ((this.cubeB().containsWhite() == false && this.cubeA().faceColors()[1].equals(this.cubeF().faceColors()[0])
            && this.cubeD().faceColors()[2].equals(this.cubeF().faceColors()[2])) == false)
            this.Ui();
          this.algorithm_InsertCubeAtPosFintoPosB();
        }
      }
    }
    listOfExplanations.add("Bring another white cube onto the U face.");
    listOfSizes.add(listOfAlgorithms.size());
  }

  public void algorithm_InsertCubeAtPosEintoPosB() {
    this.Ri();
    this.D(2);
    this.R();
    this.algorithm_InsertCubeAtPosFintoPosB();
  }

  public void algorithm_InsertCubeAtPosFintoPosA() {
    this.L();
    this.Di(2);
    this.Li();
    this.algorithm_InsertCubeAtPosEintoPosA();
  }

  public void algorithm_InsertCubeAtPosGintoPosB() {
    this.Ri();
    this.Di();
    this.R();
    this.algorithm_InsertCubeAtPosFintoPosB();
  }

  public void algorithm_InsertCubeAtPosHintoPosA() {
    this.L();
    this.D();
    this.Li();
    this.algorithm_InsertCubeAtPosEintoPosA();
  }

  public char positionOf(String cubeName) {
    char position = 'z';
    for (Cube x : this.Cubes)
      if (x.name().equals(cubeName))
        position = x.position();
    return position;
  }

  public char vacantPositionInULayer() {
    char pos = 0;
    if (this.numOfCubesWithWhiteOnUface() != 3)
      return pos;
    for (Cube x : this.LayerU())
      if (x.faceColors()[0].equals(RubiksCube.w) == false)
        pos = x.position();
    return pos;
  }

  public void algorithm_ThreeCubesWithWhiteOnUface_InCorrectPosition() {
    if (this.numOfCubesWithWhiteOnUface() != 3)
      return;
    if (this.cubesWithWhiteOnDlayer_excludingDface().length > 0) {
      if (this.cubesWithWhiteOnDlayer_excludingDface()[0].isInBlayer()
        && this.cubesWithWhiteOnDlayer_excludingDface()[0].faceColors()[1].equals(RubiksCube.w))
        this.D(2);
      else if (this.cubesWithWhiteOnDlayer_excludingDface()[0].isInLlayer()
        && this.cubesWithWhiteOnDlayer_excludingDface()[0].faceColors()[2].equals(RubiksCube.w)) {
        this.D();
      } else if (this.cubesWithWhiteOnDlayer_excludingDface()[0].isInRlayer()
        && this.cubesWithWhiteOnDlayer_excludingDface()[0].faceColors()[2].equals(RubiksCube.w))
        this.Di();
      char pos = this.cubesWithWhiteOnDlayer_excludingDface()[0].position();
      if (pos == 'E') {
        switch (this.vacantPositionInULayer()) {
        case 'B':
          this.U();
          break;
        case 'C':
          this.Ui();
          break;
        case 'D':
          this.U(2);
          break;
        }
        this.algorithm_InsertCubeAtPosEintoPosA();
      } else if (pos == 'F') {
        switch (this.vacantPositionInULayer()) {
        case 'A':
          this.Ui();
          break;
        case 'C':
          this.Ui(2);
          break;
        case 'D':
          this.U();
          break;
        }
        this.algorithm_InsertCubeAtPosFintoPosB();
      }
    } else if (this.cubesWithWhiteOnDface().length > 0) {
      switch (this.vacantPositionInULayer()) {
      case 'C':
        this.Ui();
        break;
      case 'D':
        this.U();
        break;
      }
      char pos = this.vacantPositionInULayer();
      if (pos == 'A')
        switch (this.cubesWithWhiteOnDface()[0].position()) {
        case 'E':
          this.D();
          this.algorithm_InsertCubeAtPosFintoPosA();
          break;
        case 'F':
          this.algorithm_InsertCubeAtPosFintoPosA();
          break;
        case 'G':
          this.Di();
          this.algorithm_InsertCubeAtPosHintoPosA();
          break;
        case 'H':
          this.algorithm_InsertCubeAtPosHintoPosA();
          break;
        } else if (pos == 'B')
        switch (this.cubesWithWhiteOnDface()[0].position()) {
        case 'E':
          this.algorithm_InsertCubeAtPosEintoPosB();
          break;
        case 'F':
          this.Di();
          this.algorithm_InsertCubeAtPosEintoPosB();
          break;
        case 'G':
          this.algorithm_InsertCubeAtPosGintoPosB();
          break;
        case 'H':
          this.D();
          this.algorithm_InsertCubeAtPosGintoPosB();
          break;
        }
    } else if (this.cubesWithWhiteOnUlayer_excludingUface().length > 0) {
      switch (this.cube(this.vacantPositionInULayer()).indexOf(RubiksCube.w)) {
      case 1:
        if (this.cube(this.vacantPositionInULayer()).isInBlayer())
          this.U(2);
        break;
      case 2:
        if (this.cube(this.vacantPositionInULayer()).isInLlayer())
          this.Ui();
        else
          this.U();
        break;
      }
      if (this.vacantPositionInULayer() == 'A') {
        this.L();
        this.Di();
        this.Li();
        this.algorithm_InsertCubeAtPosEintoPosA();
      } else if (this.vacantPositionInULayer() == 'B') {
        this.Ri();
        this.D();
        this.R();
        this.algorithm_InsertCubeAtPosFintoPosB();
      }
    }
  }

  public Cube cube(char pos) {
    int position = -1;
    switch (pos) {
    case 'A':
      position = 0;
      break;
    case 'B':
      position = 1;
      break;
    case 'C':
      position = 2;
      break;
    case 'D':
      position = 3;
      break;
    case 'E':
      position = 4;
      break;
    case 'F':
      position = 5;
      break;
    case 'G':
      position = 6;
      break;
    case 'H':
      position = 7;
      break;
    }
    return this.Cubes()[position];
  }

  public Cube cubeA() {
    return this.Cubes()[0];
  }

  public Cube cubeB() {
    return this.Cubes()[1];
  }

  public Cube cubeC() {
    return this.Cubes()[2];
  }

  public Cube cubeD() {
    return this.Cubes()[3];
  }

  public Cube cubeE() {
    return this.Cubes()[4];
  }

  public Cube cubeF() {
    return this.Cubes()[5];
  }

  public Cube cubeG() {
    return this.Cubes()[6];
  }

  public Cube cubeH() {
    return this.Cubes()[7];
  }

  public boolean first3WhiteCubesAreInCorrectPosition() {
    if (cubesAreInCorrectPosition(this.cubeA(), this.cubeB(), 0, 1, RubiksCube.w)
      && cubesAreInCorrectPosition(this.cubeB(), this.cubeC(), 1, 2, RubiksCube.w))
      return true;
    if (cubesAreInCorrectPosition(this.cubeC(), this.cubeD(), 0, 1, RubiksCube.w)
      && cubesAreInCorrectPosition(this.cubeB(), this.cubeC(), 1, 2, RubiksCube.w))
      return true;
    if (cubesAreInCorrectPosition(this.cubeC(), this.cubeD(), 0, 1, RubiksCube.w)
      && cubesAreInCorrectPosition(this.cubeD(), this.cubeA(), 1, 2, RubiksCube.w)) {
      return true;
    }
    if (cubesAreInCorrectPosition(this.cubeA(), this.cubeB(), 0, 1, RubiksCube.w)
      && cubesAreInCorrectPosition(this.cubeA(), this.cubeD(), 1, 2, RubiksCube.w))
      return true;
    return false;
  }

  public void algorithm_ProperlyPositionFirst3WhiteCubes() {
    if (this.numOfCubesWithWhiteOnUface() < 3)
      return;
    if (this.cubeA().faceColors()[0].equals(RubiksCube.w) == false)
      this.U(2);
    else if (this.cubeB().faceColors()[0].equals(RubiksCube.w) == false)
      this.Ui();
    else if (this.cubeC().faceColors()[0].equals(RubiksCube.w) == false)
      this.U();
    if (cubesAreInCorrectPosition(this.cubeA(), this.cubeB(), 0, 1, RubiksCube.w)) {
      this.B();
      this.R();
      this.Di();
      this.Ri();
    } else if (cubesAreInCorrectPosition(this.cubeA(), this.cubeC(), 0, 2, RubiksCube.w)) {
      this.Ri();
      this.Bi();
      this.D();
      this.B();
    } else if (cubesAreInCorrectPosition(this.cubeB(), this.cubeC(), 1, 2, RubiksCube.w)) {
      this.L();
      this.D();
      this.Li();
      this.U(2);
      this.L();
      this.Di();
      this.Li();
    }
    listOfExplanations.add("Properly position the 3rd white cube.");
    listOfSizes.add(listOfAlgorithms.size());
  }

  public boolean cubesAreInCorrectPosition(Cube one, Cube two, int i, int j, String c) {
    switch (c) {
    case RubiksCube.w:
      if (one.containsWhite() == false || two.containsWhite() == false)
        return false;
      break;
    case RubiksCube.y:
      if (one.containsYellow() == false || two.containsYellow() == false)
        return false;
      break;
    }
    switch ("" + one.position() + two.position()) {
    case "AD":
    case "DA":
    case "BC":
    case "CB":
    case "AF":
    case "FA":
    case "BE":
    case "EB":
    case "AG":
    case "GA":
    case "CE":
    case "EC":
    case "CH":
    case "HC":
    case "DG":
    case "GD":
    case "BH":
    case "HB":
    case "DF":
    case "FD":
    case "EH":
    case "HE":
    case "FG":
    case "GF":
      return this.cubesAreInCorrectPosition_diagonal(one, two, i, j);
    }
    return this.cubesAreInCorrectPosition_linear(one, two, i, j);
  }

  public boolean cubesAreInCorrectPosition_linear(Cube one, Cube two, int i, int j) {
    if (one.faceColors()[i].equals(two.faceColors()[i]) && one.faceColors()[j].equals(two.faceColors()[j]))
      return true;
    return false;
  }

  public boolean cubesAreInCorrectPosition_diagonal(Cube one, Cube two, int i, int j) {
    if (one.faceColors()[i].equals(conjugateColorOf(two.faceColors()[i]))
      && one.faceColors()[j].equals(conjugateColorOf(two.faceColors()[j])))
      return true;
    return false;
  }

  public String positionsOfNonApparentWhiteCubesInCorrectLinearPosition() {
    String positionsOfNonApparentWhiteCubesInCorrectLinearPosition = "";
    if (cubesAreInCorrectPosition(this.cubeA(), this.cubeE(), 1, 2, RubiksCube.w))
      positionsOfNonApparentWhiteCubesInCorrectLinearPosition = "AE";
    else if (cubesAreInCorrectPosition(this.cubeB(), this.cubeF(), 1, 2, RubiksCube.w))
      positionsOfNonApparentWhiteCubesInCorrectLinearPosition = "BF";
    else if (cubesAreInCorrectPosition(this.cubeE(), this.cubeF(), 0, 1, RubiksCube.w))
      positionsOfNonApparentWhiteCubesInCorrectLinearPosition = "EF";
    else if (cubesAreInCorrectPosition(this.cubeE(), this.cubeG(), 0, 2, RubiksCube.w))
      positionsOfNonApparentWhiteCubesInCorrectLinearPosition = "EG";
    else if (cubesAreInCorrectPosition(this.cubeC(), this.cubeG(), 1, 2, RubiksCube.w))
      positionsOfNonApparentWhiteCubesInCorrectLinearPosition = "CG";
    else if (cubesAreInCorrectPosition(this.cubeG(), this.cubeH(), 0, 1, RubiksCube.w)) {
      positionsOfNonApparentWhiteCubesInCorrectLinearPosition = "GH";
    } else if (cubesAreInCorrectPosition(this.cubeD(), this.cubeH(), 1, 2, RubiksCube.w))
      positionsOfNonApparentWhiteCubesInCorrectLinearPosition = "DH";
    else if (cubesAreInCorrectPosition(this.cubeF(), this.cubeH(), 0, 2, RubiksCube.w))
      positionsOfNonApparentWhiteCubesInCorrectLinearPosition = "FH";
    else if (cubesAreInCorrectPosition(this.cubeA(), this.cubeB(), 0, 1, RubiksCube.w)
      && this.cubeA().faceColors()[1].equals(RubiksCube.w))
      positionsOfNonApparentWhiteCubesInCorrectLinearPosition = "AB";
    else if (cubesAreInCorrectPosition(this.cubeA(), this.cubeC(), 0, 2, RubiksCube.w)
      && this.cubeA().faceColors()[2].equals(RubiksCube.w))
      positionsOfNonApparentWhiteCubesInCorrectLinearPosition = "AC";
    else if (cubesAreInCorrectPosition(this.cubeB(), this.cubeD(), 0, 2, RubiksCube.w)
      && this.cubeB().faceColors()[2].equals(RubiksCube.w))
      positionsOfNonApparentWhiteCubesInCorrectLinearPosition = "BD";
    else if (cubesAreInCorrectPosition(this.cubeC(), this.cubeD(), 0, 1, RubiksCube.w)
      && this.cubeC().faceColors()[1].equals(RubiksCube.w))
      positionsOfNonApparentWhiteCubesInCorrectLinearPosition = "CD";
    return positionsOfNonApparentWhiteCubesInCorrectLinearPosition;
  }

  public void addExplanation(String explanation) {
    listOfExplanations.add(explanation);
    listOfSizes.add(listOfAlgorithms.size());
  }

  public void searchFor2NonApparentWhiteCubesInCorrectLinearPosition_executeAlgorithmIfFound() {
    if (this.numOfCubesWithWhiteOnUface() > 2)
      return;
    if (this.numOfCubesWithWhiteOnUface() == 1) {
      switch (this.cubesWithWhiteOnUface()[0].position()) {
      case 'A':
        switch (this.positionsOfNonApparentWhiteCubesInCorrectLinearPosition()) {
        case "BD":
          this.R();
          this.B();
          if (this.cubeA().faceColors()[1].equals(this.cubeD().faceColors()[2])) {
            this.Fi();
            this.Ri();
            this.D();
            this.R();
          }
          break;
        case "BF":
          if (this.cubeA().faceColors()[2].equals(this.cubeF().faceColors()[1])) {
            this.R(2);
            this.B();
          } else if (this.cubeA().faceColors()[2].equals(this.cubeB().faceColors()[0])) {
            this.Ri();
            this.U();
            this.R(2);
          } else if (this.cubeA().faceColors()[1].equals(this.cubeF().faceColors()[1])) {
            if (this.cubesWithWhiteOnBlayer_excludingBface().length > 0) {
              int previousAlgorithmListSize = listOfAlgorithms.size();
              if (this.cubeD().faceColors()[2].equals(RubiksCube.w))
                this.B();
              else if (this.cubeH().faceColors()[0].equals(RubiksCube.w))
                this.B(2);
              else if (this.cubeG().faceColors()[2].equals(RubiksCube.w))
                this.Bi();
              if (listOfAlgorithms.size() > previousAlgorithmListSize)
                this.addExplanation(
                  "Bring another white cube onto the U face and pair it with the existing white cube.");
            }
            this.R();
          } else if (this.cubeA().faceColors()[1].equals(this.cubeB().faceColors()[0])) {
            this.Ri();
            this.U();
            this.R();
            this.Fi();
          }
          break;
        case "CD":
          this.Bi();
          this.Ri();
          if (this.cubeA().faceColors()[2].equals(this.cubeD().faceColors()[1])) {
            this.L();
            this.B();
            this.Di();
            this.Bi();
          }
          break;
        case "CG":
          break;
        case "DH":
          break;
        case "EF":
          break;
        case "EG":
          break;
        case "FH":
          break;
        case "GH":
          break;
        }
        break;
      case 'B':
        break;
      case 'C':
        break;
      case 'D':
        break;
      }
      switch (this.positionsOfNonApparentWhiteCubesInCorrectLinearPosition()) {
      }
    } else if (this.numOfCubesWithWhiteOnUface() == 2) {
    }

    if (cubesAreInCorrectPosition(this.cubeA(), this.cubeE(), 1, 2, RubiksCube.w))
      if (this.cubeA().faceColors()[2].equals(RubiksCube.w))
        this.F();
      else
        this.Li();
    else if (cubesAreInCorrectPosition(this.cubeB(), this.cubeF(), 1, 2, RubiksCube.w))
      if (this.cubeB().faceColors()[2].equals(RubiksCube.w))
        this.Fi();
      else
        this.R();
    else if (cubesAreInCorrectPosition(this.cubeE(), this.cubeF(), 0, 1, RubiksCube.w))
      if (this.cubeE().faceColors()[0].equals(RubiksCube.w))
        this.F(2);
      else {
        this.Fi();
        this.R();
      } else if (cubesAreInCorrectPosition(this.cubeE(), this.cubeG(), 0, 2, RubiksCube.w))
      if (this.cubeE().faceColors()[0].equals(RubiksCube.w))
        this.L(2);
      else {
        this.Li();
        this.F();
      } else if (cubesAreInCorrectPosition(this.cubeC(), this.cubeG(), 1, 2, RubiksCube.w))
      if (this.cubeC().faceColors()[1].equals(RubiksCube.w))
        this.L();
      else
        this.Bi();
    else if (cubesAreInCorrectPosition(this.cubeG(), this.cubeH(), 0, 1, RubiksCube.w)) {
      if (this.cubeG().faceColors()[0].equals(RubiksCube.w))
        this.B(2);
      else {
        this.Bi();
        this.L();
      }
    } else if (cubesAreInCorrectPosition(this.cubeD(), this.cubeH(), 1, 2, RubiksCube.w))
      if (this.cubeD().faceColors()[1].equals(RubiksCube.w))
        this.Ri();
      else
        this.B();
    else if (cubesAreInCorrectPosition(this.cubeF(), this.cubeH(), 0, 2, RubiksCube.w))
      if (this.cubeF().faceColors()[0].equals(RubiksCube.w))
        this.R(2);
      else {
        this.R();
        this.Fi();
      } else if (cubesAreInCorrectPosition(this.cubeA(), this.cubeB(), 0, 1, RubiksCube.w)
      && this.cubeA().faceColors()[1].equals(RubiksCube.w)) {
      this.F();
      this.R();
    } else if (cubesAreInCorrectPosition(this.cubeA(), this.cubeC(), 0, 2, RubiksCube.w)
      && this.cubeA().faceColors()[2].equals(RubiksCube.w)) {
      this.L();
      this.F();
    } else if (cubesAreInCorrectPosition(this.cubeB(), this.cubeD(), 0, 2, RubiksCube.w)
      && this.cubeB().faceColors()[2].equals(RubiksCube.w)) {
      this.Ri();
      this.Fi();
    } else if (cubesAreInCorrectPosition(this.cubeC(), this.cubeD(), 0, 1, RubiksCube.w)
      && this.cubeC().faceColors()[1].equals(RubiksCube.w)) {
      this.F();
      this.R();
    }
  }

  public void searchFor2NonApparentWhiteCubesInCorrectPosition_executeAlgorithmIfFound() {
    for (int i = 0; i < 2; i++) {
      if (this.numOfCubesWithWhiteOnUface() > 2)
        return;
      if (cubesAreInCorrectPosition(this.cubeA(), this.cubeE(), 1, 2, RubiksCube.w))
        if (this.cubeA().faceColors()[2].equals(RubiksCube.w))
          this.F();
        else
          this.Li();
      else if (cubesAreInCorrectPosition(this.cubeB(), this.cubeF(), 1, 2, RubiksCube.w))
        if (this.cubeB().faceColors()[2].equals(RubiksCube.w))
          this.Fi();
        else
          this.R();
      else if (cubesAreInCorrectPosition(this.cubeE(), this.cubeF(), 0, 1, RubiksCube.w))
        if (this.cubeE().faceColors()[0].equals(RubiksCube.w))
          this.F(2);
        else {
          this.Fi();
          this.R();
        } else if (cubesAreInCorrectPosition(this.cubeE(), this.cubeG(), 0, 2, RubiksCube.w))
        if (this.cubeE().faceColors()[0].equals(RubiksCube.w))
          this.L(2);
        else {
          this.Li();
          this.F();
        } else if (cubesAreInCorrectPosition(this.cubeC(), this.cubeG(), 1, 2, RubiksCube.w))
        if (this.cubeC().faceColors()[1].equals(RubiksCube.w))
          this.L();
        else
          this.Bi();
      else if (cubesAreInCorrectPosition(this.cubeG(), this.cubeH(), 0, 1, RubiksCube.w)) {
        if (this.cubeG().faceColors()[0].equals(RubiksCube.w))
          this.B(2);
        else {
          this.Bi();
          this.L();
        }
      } else if (cubesAreInCorrectPosition(this.cubeD(), this.cubeH(), 1, 2, RubiksCube.w))
        if (this.cubeD().faceColors()[1].equals(RubiksCube.w))
          this.Ri();
        else
          this.B();
      else if (cubesAreInCorrectPosition(this.cubeF(), this.cubeH(), 0, 2, RubiksCube.w))
        if (this.cubeF().faceColors()[0].equals(RubiksCube.w))
          this.R(2);
        else {
          this.R();
          this.Fi();
        } else if (cubesAreInCorrectPosition(this.cubeA(), this.cubeF(), 0, 2, RubiksCube.w)
        || cubesAreInCorrectPosition(this.cubeB(), this.cubeE(), 0, 2, RubiksCube.w)) {
        this.Li();
        this.R();
      } else if (cubesAreInCorrectPosition(this.cubeA(), this.cubeG(), 0, 1, RubiksCube.w)
        || cubesAreInCorrectPosition(this.cubeC(), this.cubeE(), 0, 1, RubiksCube.w)) {
        this.F();
        this.Bi();
      } else if (cubesAreInCorrectPosition(this.cubeC(), this.cubeH(), 0, 2, RubiksCube.w)
        || cubesAreInCorrectPosition(this.cubeD(), this.cubeG(), 0, 2, RubiksCube.w)) {
        this.L();
        this.Ri();
      } else if (cubesAreInCorrectPosition(this.cubeB(), this.cubeH(), 0, 1, RubiksCube.w)
        || cubesAreInCorrectPosition(this.cubeD(), this.cubeF(), 0, 1, RubiksCube.w)) {
        this.Fi();
        this.B();
      } else if (cubesAreInCorrectPosition(this.cubeE(), this.cubeH(), 1, 2, RubiksCube.w)
        || cubesAreInCorrectPosition(this.cubeF(), this.cubeG(), 1, 2, RubiksCube.w)) {
        this.R(2);
        this.L(2);
      } else if (cubesAreInCorrectPosition(this.cubeA(), this.cubeB(), 0, 1, RubiksCube.w)
        && this.cubeA().faceColors()[1].equals(RubiksCube.w)) {
        this.F();
        this.R();
      } else if (cubesAreInCorrectPosition(this.cubeA(), this.cubeC(), 0, 2, RubiksCube.w)
        && this.cubeA().faceColors()[2].equals(RubiksCube.w)) {
        this.L();
        this.F();
      } else if (cubesAreInCorrectPosition(this.cubeB(), this.cubeD(), 0, 2, RubiksCube.w)
        && this.cubeB().faceColors()[2].equals(RubiksCube.w)) {
        this.Ri();
        this.Fi();
      } else if (cubesAreInCorrectPosition(this.cubeC(), this.cubeD(), 0, 1, RubiksCube.w)
        && this.cubeC().faceColors()[1].equals(RubiksCube.w)) {
        this.F();
        this.R();
      }
      if (this.layerU_isSolved()) {
        listOfSizes.add(listOfAlgorithms.size() - 1);
        listOfExplanations.add("Pair the first two white cubes on the U face.");
        listOfSizes.add(listOfAlgorithms.size());
        listOfExplanations.add("Bring the properly oriented pair of white cubes to the U face.");
      } else if (listOfSizes.size() == 0 && listOfAlgorithms.size() > 0) {
        if (i == 0)
          listOfExplanations.add("Bring the properly oriented pair of white cubes to the U face.");
        else
          listOfExplanations.add("Bring the other properly oriented pair of white cubes to the U face.");
        listOfSizes.add(listOfAlgorithms.size());
      } else if (listOfSizes.size() > 0 && listOfAlgorithms.size() > listOfSizes.get(listOfSizes.size() - 1)) {
        if (i == 0)
          listOfExplanations.add("Bring the properly oriented pair of white cubes to the U face.");
        else
          listOfExplanations.add("Bring the other properly oriented pair of white cubes to the U face.");
        listOfSizes.add(listOfAlgorithms.size());
      }
    }
  }

  public void algorithm_NoCubesWithWhiteOnUface() {
    if (this.numOfCubesWithWhiteOnUface() != 0)
      return;
    if (this.cubesWithWhiteOnDlayer_excludingDface().length > 0) {
      switch (this.cubesWithWhiteOnDlayer_excludingDface()[0].position()) {
      case 'E':
        if (this.cubesWithWhiteOnDlayer_excludingDface()[0].faceColors()[1].equals(RubiksCube.w))
          this.Li();
        else
          this.F();
        break;
      case 'F':
        if (this.cubesWithWhiteOnDlayer_excludingDface()[0].faceColors()[1].equals(RubiksCube.w))
          this.R();
        else
          this.Fi();
        break;
      case 'G':
        if (this.cubesWithWhiteOnDlayer_excludingDface()[0].faceColors()[1].equals(RubiksCube.w))
          this.L();
        else
          this.Bi();
        break;
      case 'H':
        if (this.cubesWithWhiteOnDlayer_excludingDface()[0].faceColors()[1].equals(RubiksCube.w))
          this.Ri();
        else
          this.B();
        break;
      }
    } else if (this.cubesWithWhiteOnUlayer_excludingUface().length > 0) {
      switch (this.cubesWithWhiteOnUlayer_excludingUface()[0].position()) {
      case 'A':
        if (this.cubesWithWhiteOnUlayer_excludingUface()[0].faceColors()[1].equals(RubiksCube.w))
          this.Li();
        else
          this.F();
        break;
      case 'B':
        if (this.cubesWithWhiteOnUlayer_excludingUface()[0].faceColors()[1].equals(RubiksCube.w))
          this.R();
        else
          this.Fi();
        break;
      case 'C':
        if (this.cubesWithWhiteOnUlayer_excludingUface()[0].faceColors()[1].equals(RubiksCube.w))
          this.L();
        else
          this.Bi();
        break;
      case 'D':
        if (this.cubesWithWhiteOnUlayer_excludingUface()[0].faceColors()[1].equals(RubiksCube.w))
          this.Ri();
        else
          this.B();
        break;
      }
    } else if (this.cubesWithWhiteOnDlayer_excludingDface().length == 0
      && this.cubesWithWhiteOnUlayer_excludingUface().length == 0) {
      this.R(2);
      this.L(2);
    }
    if (this.numOfCubesWithWhiteOnUface() == 1)
      listOfExplanations.add("Bring a white cube on to the U face.");
    else if (this.numOfCubesWithWhiteOnUface() == 2)
      listOfExplanations.add("Bring two white cubes on to the U face.");
    listOfSizes.add(listOfAlgorithms.size());
  }

  public Cube[] cubesWithWhiteOnUlayer_excludingUface() {
    ArrayList<Cube> cubesWithWhiteOnUlayer_excludingUface = new ArrayList<Cube>();
    for (Cube x : this.whiteCubes())
      if (x.isInUlayer() && x.faceColors()[0].equals(RubiksCube.w) == false)
        cubesWithWhiteOnUlayer_excludingUface.add(x);
    return toCubeArray(cubesWithWhiteOnUlayer_excludingUface);
  }

  public Cube[] cubesWithWhiteOnDlayer_excludingDface() {
    ArrayList<Cube> cubesWithWhiteOnDlayer_excludingDface = new ArrayList<Cube>();
    for (Cube x : this.whiteCubes())
      if (x.isInDlayer() && x.faceColors()[0].equals(RubiksCube.w) == false)
        cubesWithWhiteOnDlayer_excludingDface.add(x);
    return toCubeArray(cubesWithWhiteOnDlayer_excludingDface);
  }

  public Cube[] cubesWithWhiteOnRlayer_excludingRface() {
    ArrayList<Cube> cubesWithWhiteOnRlayer_excludingRface = new ArrayList<Cube>();
    for (Cube x : this.whiteCubes())
      if (x.isInRlayer() && x.faceColors()[2].equals(RubiksCube.w) == false)
        cubesWithWhiteOnRlayer_excludingRface.add(x);
    return toCubeArray(cubesWithWhiteOnRlayer_excludingRface);
  }

  public Cube[] cubesWithWhiteOnLlayer_excludingLface() {
    ArrayList<Cube> cubesWithWhiteOnLlayer_excludingLface = new ArrayList<Cube>();
    for (Cube x : this.whiteCubes())
      if (x.isInLlayer() && x.faceColors()[2].equals(RubiksCube.w) == false)
        cubesWithWhiteOnLlayer_excludingLface.add(x);
    return toCubeArray(cubesWithWhiteOnLlayer_excludingLface);
  }

  public Cube[] cubesWithWhiteOnFlayer_excludingFface() {
    ArrayList<Cube> cubesWithWhiteOnFlayer_excludingFface = new ArrayList<Cube>();
    for (Cube x : this.whiteCubes())
      if (x.isInFlayer() && x.faceColors()[1].equals(RubiksCube.w) == false)
        cubesWithWhiteOnFlayer_excludingFface.add(x);
    return toCubeArray(cubesWithWhiteOnFlayer_excludingFface);
  }

  public Cube[] cubesWithWhiteOnBlayer_excludingBface() {
    ArrayList<Cube> cubesWithWhiteOnBlayer_excludingBface = new ArrayList<Cube>();
    for (Cube x : this.whiteCubes())
      if (x.isInBlayer() && x.faceColors()[1].equals(RubiksCube.w) == false)
        cubesWithWhiteOnBlayer_excludingBface.add(x);
    return toCubeArray(cubesWithWhiteOnBlayer_excludingBface);
  }

  public Cube[] cubesWithWhiteOnUface() {
    Cube[] cubesWithWhiteOnUface = new Cube[this.numOfCubesWithWhiteOnUface()];
    int cubesWithWhiteOnUface_Index = 0;
    for (int i = 0; i < this.whiteCubes().length; i++)
      if (this.whiteCubes()[i].faceColors()[0].equals(RubiksCube.w) && this.whiteCubes()[i].isInUlayer())
        cubesWithWhiteOnUface[cubesWithWhiteOnUface_Index++] = this.whiteCubes()[i];
    return cubesWithWhiteOnUface;
  }

  public Cube[] cubesWithWhiteOnDface() {
    Cube[] cubesWithWhiteOnDface = new Cube[this.numOfCubesWithWhiteOnDface()];
    int cubesWithWhiteOnDface_Index = 0;
    for (int i = 0; i < this.whiteCubes().length; i++)
      if (this.whiteCubes()[i].faceColors()[0].equals(RubiksCube.w) && this.whiteCubes()[i].isInDlayer())
        cubesWithWhiteOnDface[cubesWithWhiteOnDface_Index++] = this.whiteCubes()[i];
    return cubesWithWhiteOnDface;
  }

  public Cube[] whiteCubes() {
    Cube[] whiteCubes = new Cube[4];
    int whiteCubes_Index = 0;
    for (int i = 0; i < this.Cubes().length; i++)
      if (this.Cubes()[i].containsWhite())
        whiteCubes[whiteCubes_Index++] = this.Cubes()[i];
    return whiteCubes;
  }

  public Cube[] yellowCubes() {
    Cube[] yellowCubes = new Cube[4];
    int yellowCubesIndex = 0;
    for (int i = 0; i < this.Cubes().length; i++)
      if (this.Cubes()[i].containsYellow())
        yellowCubes[yellowCubesIndex++] = this.Cubes()[i];
    return yellowCubes;
  }

  public int numOfCubesWithYellowOnDface() {
    int numOfCubesWithYellowOnDface = 0;
    for (Cube x : this.yellowCubes())
      if (x.faceColors()[0].equals(RubiksCube.y) && x.isInDlayer())
        numOfCubesWithYellowOnDface++;
    return numOfCubesWithYellowOnDface;
  }

  public Cube[] cubesWithYellowOnDface() {
    Cube[] cubesWithYellowOnDface = new Cube[this.numOfCubesWithYellowOnDface()];
    int cubesWithYellowOnDface_Index = 0;
    for (int i = 0; i < this.yellowCubes().length; i++)
      if (this.yellowCubes()[i].faceColors()[0].equals(RubiksCube.y) && this.yellowCubes()[i].isInDlayer())
        cubesWithYellowOnDface[cubesWithYellowOnDface_Index++] = this.yellowCubes()[i];
    return cubesWithYellowOnDface;
  }

  public void algorithm_YellowFace_Left_Unconventional() {
    this.L();
    this.D();
    this.Li();
    this.D();
    this.L();
    this.D(2);
    this.Li();
  }

  public void algorithm_YellowFace_Right_Unconventional() {
    this.Ri();
    this.Di();
    this.R();
    this.Di();
    this.Ri();
    this.Di(2);
    this.R();
  }

  public void algorithm_OneCubeWithYellowOnDface() {
    if (this.numOfCubesWithYellowOnDface() != 1)
      return;
    switch (this.cubesWithYellowOnDface()[0].position()) {
    case 'E':
      if (this.cubeF().faceColors()[1].equals(RubiksCube.y))
        this.algorithm_YellowFace_Right_Unconventional();
      else {
        this.D();
        this.algorithm_YellowFace_Left_Unconventional();
      }
      break;
    case 'F':
      if (this.cubeE().faceColors()[1].equals(RubiksCube.y))
        this.algorithm_YellowFace_Left_Unconventional();
      else {
        this.Di();
        this.algorithm_YellowFace_Right_Unconventional();
      }
      break;
    case 'G':
      if (this.cubeH().faceColors()[1].equals(RubiksCube.y)) {
        this.D(2);
        this.algorithm_YellowFace_Left_Unconventional();
      } else {
        this.D();
        this.algorithm_YellowFace_Right_Unconventional();
      }
      break;
    case 'H':
      if (this.cubeG().faceColors()[1].equals(RubiksCube.y)) {
        this.D(2);
        this.algorithm_YellowFace_Right_Unconventional();
      } else {
        this.Di();
        this.algorithm_YellowFace_Left_Unconventional();
      }
      break;
    }
  }

  public void algorithm_YellowFace_Unconventional() {
    if (this.faceD_isSolved())
      return;
    if (this.numOfCubesWithYellowOnDface() == 0)
      this.algorithm_YellowFace_Left_Unconventional();
    while (this.numOfCubesWithYellowOnDface() == 2) {
      switch ("" + this.cubesWithYellowOnDface()[0].position() + this.cubesWithYellowOnDface()[1].position()) {
      case "EF":
      case "FE":
        this.D(2);
        break;
      case "EG":
      case "GE":
        this.Di();
        break;
      case "FH":
      case "HF":
        this.D();
        break;
      }
      this.algorithm_YellowFace_Left_Unconventional();
      if (this.numOfCubesWithYellowOnDface() == 0)
        this.algorithm_YellowFace_Left_Unconventional();
    }
    if (this.numOfCubesWithYellowOnDface() == 1)
      this.algorithm_OneCubeWithYellowOnDface();
  }

  public void algorithm_finalStep_Unconventional() {
    this.Li();
    this.F();
    this.Li();
    this.B(2);
    this.L();
    this.Fi();
    this.Li();
    this.B(2);
    this.L(2);
    this.Di();
  }

  public boolean layerD_isSolved() {
    if (cubesAreInCorrectPosition(this.cubeE(), this.cubeF(), 0, 1, RubiksCube.y)
      && cubesAreInCorrectPosition(this.cubeG(), this.cubeH(), 0, 1, RubiksCube.y)
      && cubesAreInCorrectPosition(this.cubeE(), this.cubeG(), 0, 2, RubiksCube.y)
      && cubesAreInCorrectPosition(this.cubeF(), this.cubeH(), 0, 2, RubiksCube.y))
      return true;
    return false;
  }

  public boolean layerU_isSolved() {
    if (cubesAreInCorrectPosition(this.cubeA(), this.cubeB(), 0, 1, RubiksCube.w)
      && cubesAreInCorrectPosition(this.cubeC(), this.cubeD(), 0, 1, RubiksCube.w)
      && cubesAreInCorrectPosition(this.cubeA(), this.cubeC(), 0, 2, RubiksCube.w)
      && cubesAreInCorrectPosition(this.cubeB(), this.cubeD(), 0, 2, RubiksCube.w))
      return true;
    return false;
  }

  public void verifyThatCubeIsSolved_ifNotExecuteAlgorithm() {
    if (this.isSolved() == false && this.layerU_isSolved() && this.layerD_isSolved() == false) {
      this.D(2);
      this.algorithm_finalStep_Unconventional();
    }
    while (this.isSolved() == false && this.layerD_isSolved() && this.layerU_isSolved())
      this.U();
  }

  public void algorithm_finalStep_YellowLayer_Unconventional() {
    if (this.faceD_isSolved() == false || this.layerD_isSolved() == true)
      return;
    if (cubesAreInCorrectPosition(this.cubeE(), this.cubeF(), 0, 1, RubiksCube.y))
      this.D(2);
    else if (cubesAreInCorrectPosition(this.cubeE(), this.cubeG(), 0, 2, RubiksCube.y))
      this.Di();
    else if (cubesAreInCorrectPosition(this.cubeF(), this.cubeH(), 0, 2, RubiksCube.y))
      this.D();
    this.algorithm_finalStep_Unconventional();
  }

  public void solveCube() {
    this.algorithm_WhiteLayer();
    this.algorithm_YellowLayer();
    this.verifyThatCubeIsSolved_ifNotExecuteAlgorithm();
    solved = true;
  }

  void resetLists() {
    listOfAlgorithms = new ArrayList<String>();
    listOfAlgorithms_original = new ArrayList<String>();
    listOfExplanations = new ArrayList<String>();
    listOfSizes = new ArrayList<Integer>();
  }

  public void solve() {
    showCounter = true;
    resetLists();
    initialCubes = copyOf(this.Cubes);
    this.solveCube();
    solved = true;
    this.update(initialCubes);
    moveSequence = sequence(this.algorithmList());
  }

  public void algorithm_YellowLayer() {
    this.algorithm_YellowFace_Unconventional();
    this.algorithm_finalStep_YellowLayer_Unconventional();
  }

  public void algorithm_WhiteLayer() {
    if (this.numOfCubesWithWhiteOnUface() == 0) {
      this.searchFor2NonApparentWhiteCubesInCorrectPosition_executeAlgorithmIfFound();
      this.algorithm_NoCubesWithWhiteOnUface();
    }
    if (this.numOfCubesWithWhiteOnUface() == 1) {
      this.searchFor2NonApparentWhiteCubesInCorrectLinearPosition_executeAlgorithmIfFound();
      this.algorithm_OneCubeWithWhiteOnUface();
    }
    if (this.first2WhiteCubesAreInCorrectPosition() == false)
      this.algorithm_ProperlyPositionFirst2WhiteCubes();
    if (this.numOfCubesWithWhiteOnUface() == 2) {
      this.searchFor2NonApparentWhiteCubesInCorrectLinearPosition_executeAlgorithmIfFound();
      this.algorithm_TwoCubesWithWhiteOnUface_InCorrectPosition();
    }
    if (this.first3WhiteCubesAreInCorrectPosition() == false) {
      this.algorithm_ProperlyPositionFirst3WhiteCubes();
    }
    if (this.numOfCubesWithWhiteOnUface() == 3)
      this.algorithm_ThreeCubesWithWhiteOnUface_InCorrectPosition();
  }

  public void displayAlgorithmList() {
    System.out.println(Arrays.toString(listOfAlgorithms.toArray()));
  }

  public void displayOptimizedAlgorithmList() {
    optimizeAlgorithmList();
    this.displayAlgorithmList();
  }

  public void displayAlgorithmList_Formatted() {
    for (int i = 0; i < listOfAlgorithms.size(); i++) {
      System.out.print(listOfAlgorithms.get(i));
      if (listOfAlgorithms.get(i).length() == 1)
        System.out.print(" ");
      if (i == listOfAlgorithms.size() - 1)
        System.out.print(" = ");
      else
        System.out.print(" + ");
      if ((i + 1) % 8 == 0)
        System.out.println("\n");
    }
    System.out.println("[" + listOfAlgorithms.size() + "]");
  }

  public void displayOptimizedAlgorithmList_Formatted() {
    optimizeAlgorithmList();
    this.displayAlgorithmList_Formatted();
  }

  public void displayOriginalAlgorithmList_Formatted() {
    optimizeAlgorithmList();
    for (int i = 0; i < listOfAlgorithms_original.size(); i++) {
      System.out.print(listOfAlgorithms_original.get(i));
      if (listOfAlgorithms_original.get(i).length() == 1)
        System.out.print(" ");
      if (i == listOfAlgorithms_original.size() - 1)
        System.out.print(" = ");
      else
        System.out.print(" + ");
      if ((i + 1) % 8 == 0)
        System.out.println("\n");
    }
    System.out.println("[" + listOfAlgorithms_original.size() + "]");
  }

  public void displayExplanations() {
    int index = 0;
    for (int i = 0; i < listOfExplanations.size(); i++) {
      System.out.print("#" + (i + 1) + ") ");
      System.out.println(listOfExplanations.get(i));
      System.out.print(" -> ");
      String[] algorithm = new String[listOfSizes.get(i) - index];
      for (int j = index; j < algorithm.length + index; j++)
        algorithm[j - index] = listOfAlgorithms_original.get(j);
      System.out.println(Arrays.toString(algorithm) + "\n");
      index += algorithm.length;
    }
    System.out.println(" -- The cube is now solved! -- ");
  }

  public RubiksCube_2x2 new_RubiksCube_2x2 (Move[] scrambleAlgorithm) {
    RubiksCube_2x2 scramble = new RubiksCube_2x2(cubes);
    for (Move m : scrambleAlgorithm)
      if (m.equals(F))
        scramble.F();
      else if (m.equals(Fi))
        scramble.Fi();
      else if (m.equals(L))
        scramble.L();
      else if (m.equals(Li))
        scramble.Li();
      else if (m.equals(D))
        scramble.D();
      else if (m.equals(Di))
        scramble.Di();
      else if (m.equals(R))
        scramble.R();
      else if (m.equals(Ri))
        scramble.Ri();
      else if (m.equals(B))
        scramble.B();
      else if (m.equals(Bi))
        scramble.Bi();
      else if (m.equals(U))
        scramble.U();
      else if (m.equals(Ui))
        scramble.Ui();
    return scramble;
  }

  public RubiksCube_2x2 scramble (ArrayList<Move> scrambleAlgorithm) {
    Cube[] cubes = new Cube[8];
    cubes[0] = new Cube(RubiksCube.WBR, RubiksCube.A, 1);
    cubes[1] = new Cube(RubiksCube.WBP, RubiksCube.B, 1);
    cubes[2] = new Cube(RubiksCube.WGR, RubiksCube.C, 1);
    cubes[3] = new Cube(RubiksCube.WGP, RubiksCube.D, 1);
    cubes[4] = new Cube(RubiksCube.YBR, RubiksCube.E, 1);
    cubes[5] = new Cube(RubiksCube.YBP, RubiksCube.F, 1);
    cubes[6] = new Cube(RubiksCube.YGR, RubiksCube.G, 1);
    cubes[7] = new Cube(RubiksCube.YGP, RubiksCube.H, 1);
    RubiksCube_2x2 scramble = new RubiksCube_2x2(cubes);
    for (Move m : scrambleAlgorithm)
      if (m.equals(F))
        scramble.F();
      else if (m.equals(Fi))
        scramble.Fi();
      else if (m.equals(L))
        scramble.L();
      else if (m.equals(Li))
        scramble.Li();
      else if (m.equals(D))
        scramble.D();
      else if (m.equals(Di))
        scramble.Di();
      else if (m.equals(R))
        scramble.R();
      else if (m.equals(Ri))
        scramble.Ri();
      else if (m.equals(B))
        scramble.B();
      else if (m.equals(Bi))
        scramble.Bi();
      else if (m.equals(U))
        scramble.U();
      else if (m.equals(Ui))
        scramble.Ui();
    return scramble;
  }
}


public static int colorID(String c) {
  if (c.equals(RubiksCube.w) || c.equals(RubiksCube.y))
    return 1;
  if (c.equals(RubiksCube.b) || c.equals(RubiksCube.g))
    return 2;
  if (c.equals(RubiksCube.r) || c.equals(RubiksCube.p))
    return 3;
  return -1;
}

static final String[] WBR_options = { RubiksCube.w, RubiksCube.b, RubiksCube.r };
static final String[] WBP_options = { RubiksCube.w, RubiksCube.b, RubiksCube.p };
static final String[] WGR_options = { RubiksCube.w, RubiksCube.g, RubiksCube.r };
static final String[] WGP_options = { RubiksCube.w, RubiksCube.g, RubiksCube.p };
static final String[] YBR_options = { RubiksCube.y, RubiksCube.b, RubiksCube.r };
static final String[] YBP_options = { RubiksCube.y, RubiksCube.b, RubiksCube.p };
static final String[] YGR_options = { RubiksCube.y, RubiksCube.g, RubiksCube.r };
static final String[] YGP_options = { RubiksCube.y, RubiksCube.g, RubiksCube.p };

public static int Orientation (String cubeName, String primaryFaceColor)
{
  String[] cubeColors = new String[3];
  switch (cubeName) {
  case RubiksCube.WBR:
    cubeColors = WBR_options;
    break;
  case RubiksCube.WBP:
    cubeColors = WBP_options;
    break;
  case RubiksCube.WGR:
    cubeColors = WGR_options;
    break;
  case RubiksCube.WGP:
    cubeColors = WGP_options;
    break;
  case RubiksCube.YBR:
    cubeColors = YBR_options;
    break;
  case RubiksCube.YBP:
    cubeColors = YBP_options;
    break;
  case RubiksCube.YGR:
    cubeColors = YGR_options;
    break;
  case RubiksCube.YGP:
    cubeColors = YGP_options;
    break;
  }

  int orientation = 0;

  if (primaryFaceColor.equals(cubeColors[0]))
  {
    orientation = 1;
  }
  if (primaryFaceColor.equals(cubeColors[1]))
  {
    orientation = 2;
  }
  if (primaryFaceColor.equals(cubeColors[2]))
  {
    orientation = 3;
  }

  return orientation;
}

static final int[] clockwise = { 3, 0, 1, 2 };
static final int[] anti_clockwise = { 1, 2, 3, 0 };

public static String conjugateColorOf(String c) {
  switch (c) {
  case RubiksCube.w:
    return RubiksCube.y;
  case RubiksCube.y:
    return RubiksCube.w;
  case RubiksCube.r:
    return RubiksCube.p;
  case RubiksCube.p:
    return RubiksCube.r;
  case RubiksCube.b:
    return RubiksCube.g;
  case RubiksCube.g:
    return RubiksCube.b;
  }
  return null;
}

public static final String U_ = "U";
public static final String Ui_ = "Ui";
public static final String D_ = "D";
public static final String Di_ = "Di";
public static final String R_ = "R";
public static final String Ri_ = "Ri";
public static final String L_ = "L";
public static final String Li_ = "Li";
public static final String F_ = "F";
public static final String Fi_ = "Fi";
public static final String B_ = "B";
public static final String Bi_ = "Bi";

public static String complementOf(String operation) {
  String complement = "";
  switch (operation) {
  case U_:
    complement = Di_;
    break;
  case Ui_:
    complement = D_;
    break;
  case R_:
    complement = Li_;
    break;
  case Ri_:
    complement = L_;
    break;
  case L_:
    complement = Ri_;
    break;
  case Li_:
    complement = R_;
    break;
  case B_:
    complement = Fi_;
    break;
  case Bi_:
    complement = F_;
    break;
  case F_:
    complement = Bi_;
    break;
  case Fi_:
    complement = B_;
    break;
  case D_:
    complement = Ui_;
    break;
  case Di_:
    complement = U_;
    break;
  }
  return complement;
}

public static String inverseOf(String operation) {
  String inverse = "";
  switch (operation) {
  case U_:
    inverse = Ui_;
    break;
  case Ui_:
    inverse = U_;
    break;
  case R_:
    inverse = Ri_;
    break;
  case Ri_:
    inverse = R_;
    break;
  case L_:
    inverse = Li_;
    break;
  case Li_:
    inverse = L_;
    break;
  case B_:
    inverse = Bi_;
    break;
  case Bi_:
    inverse = B_;
    break;
  case F_:
    inverse = Fi_;
    break;
  case Fi_:
    inverse = F_;
    break;
  case D_:
    inverse = Di_;
    break;
  case Di_:
    inverse = D_;
    break;
  }
  return inverse;
}

public static Cube[] toCubeArray(ArrayList<Cube> cubeArrayList) {
  Cube[] cubeArray = new Cube[cubeArrayList.size()];
  for (int i = 0; i < cubeArray.length; i++)
    cubeArray[i] = cubeArrayList.get(i);
  return cubeArray;
}

public static String string(String[] a) {
  String string = "";
  for (int i = 0; i < a.length; i++) {
    string += a[i] + "\n";
  }
  return string;
}

public static String string(int[] a) {
  String string = "";
  for (int i = 0; i < a.length; i++) {
    string += a[i] + "\n";
  }
  return string;
}

public static String string(Cube[] a) {
  String string = "";
  for (int i = 0; i < a.length; i++) {
    string += "" + a[i] + "\n";
  }
  return string;
}

final static String cubePositionNames = "ABCDEFGH";
final static String header = "2x2 Rubik's Cube Solver";
final static String CubeNamingScheme = "Cube Naming Scheme";

public static String orientationInfo(Cube cube) {
  String face1 = "", face2 = "", face3 = "", f1 = cube.faceDesignations()[0], f2 = cube.faceDesignations()[1], 
    f3 = cube.faceDesignations()[2];
  String[] faces = cube.faces();
  int[] faceNumbers = cube.faceNumbers();
  if (cube.orientationType() == 1) {
    switch (cube.orientation()) {
    case 1:
      face1 = faces[faceNumbers[0]];
      face2 = faces[faceNumbers[1]];
      face3 = faces[faceNumbers[2]];
      break;
    case 2:
      face1 = faces[faceNumbers[1]];
      face2 = faces[faceNumbers[2]];
      face3 = faces[faceNumbers[0]];
      break;
    case 3:
      face1 = faces[faceNumbers[2]];
      face2 = faces[faceNumbers[0]];
      face3 = faces[faceNumbers[1]];
      break;
    }
  } else {
    switch (cube.orientation()) {
    case 1:
      face1 = faces[faceNumbers[0]];
      face2 = faces[faceNumbers[1]];
      face3 = faces[faceNumbers[2]];
      break;
    case 2:
      face1 = faces[faceNumbers[2]];
      face2 = faces[faceNumbers[0]];
      face3 = faces[faceNumbers[1]];
      break;
    case 3:
      face1 = faces[faceNumbers[1]];
      face2 = faces[faceNumbers[2]];
      face3 = faces[faceNumbers[0]];
      break;
    }
  }
  return cube.name() + "\n" + f1 + ") " + face1 + "\n" + f2 + ") " + face2 + "\n" + f3 + ") " + face3;
}

public static Cube[] copyOf(Cube[] arr) {
  Cube[] copy = new Cube[arr.length];
  for (int i = 0; i < copy.length; i++)
    copy[i] = arr[i].copy();
  return copy;
}

public static ArrayList<Move> copyOf(ArrayList<Move> arr) {
  ArrayList<Move> copy = new ArrayList<Move>();
  for (int i = 0; i < arr.size(); i++)
    copy.add(arr.get(i));
  return copy;
}

public void highlight (int i) {
  cubies[i].highlight();
}

public void unhighlight (int i) {
  cubies[i].unhighlight();
}

public void highlight (int i, int j) {
  cubies[i].highlight(j);
}

public color toColor (String s) {
  switch (s) {
  case RubiksCube.w: 
    return white;
  case RubiksCube.y: 
    return yellow;
  case RubiksCube.b: 
    return blue;
  case RubiksCube.g: 
    return green;
  case RubiksCube.r: 
    return red;
  case RubiksCube.p: 
    return purple;
  }
  return black;
}


float textHeight(String text) {
  float textHeight = textAscent() + textDescent();
  return textHeightMultiplier(text) * textHeight;
}

float textHeightMultiplier (String text) {
  switch (text) {
  case maxCount :
    return 0.65;
  case "ON":
  case "OFF":
    return 0.625;
  case welcomeText :
    return 1.2;
  }
  return 1;
}

final String 
  title = "The 2x2 Rubik's Cube Solver", 
  solveAlertMessage = "The Cube Is Already Solved - Try The Scramble Button", 
  controlsText = "You Can Use Your Keyboard Too!", 
  maxCount = "99", 
  welcomeText = "Welcome, Press Any Key To Begin!";
;

String[] textArr = {title, solveAlertMessage, scrambleName, controlsText, maxCount};

float 
  titleTextSize = 77.5, 
  alertTextSize = 34.5, 
  primaryButtonTextSize = 43.5, 
  controlsTextSize = 33, 
  counterTextSize = 16;

float[] textSizeArr = {titleTextSize, alertTextSize, primaryButtonTextSize, controlsTextSize, counterTextSize};

void textSizeSetup() {
  textSizeSetup(title, 0.56, displayWidth);
  textSizeSetup(solveAlertMessage, 0.475, displayWidth);
  textSizeSetup(scrambleName, 0.1, displayWidth);
  textSizeSetup(controlsText, 0.25, displayWidth);
  textSizeSetup(maxCount, 0.0527, displayWidth);
  saveTextSizes();
}

void textSizeSetup (String text, float percent, float comp) {
  int index = -1;
  float textSize = 0, min = 0.95 * percent, max = 1.05 * percent;
  for (int i = 0; i < textArr.length; i++)
    if (textArr[i].equals(text)) {
      textSize = textSizeArr[i];
      textSize(textSize);
      index = i;
    }

  boolean increaseTextSize = false;
  if (textWidth(text) < min * comp)
    increaseTextSize = true;

  if (increaseTextSize)
    while (textWidth(text) < min * comp) {
      textSize++;
      textSize(textSize);
    } else 
  while (textWidth(text) > max * comp) {
    textSize--;
    textSize(textSize);
  }

  textSizeArr[index] = textSize;
}

void setTextSize(String s) {
  float textSize = 0;
  switch(s) { 
  case scrambleName:
  case solveName:
  case inputCubeName:
  case controlsName:
  case fName:
  case fiName:
  case uName:
  case uiName:
  case rName:
  case riName:
  case lName:
  case liName:
  case dName:
  case diName:
  case bName:
  case biName:
    textSize = primaryButtonTextSize;
    break;
  case doneButtonName:
    textSize = 0.6 * primaryButtonTextSize;
    break;
  }
  textSize(textSize);
}

void saveTextSizes() {
  titleTextSize = textSizeArr[0];
  alertTextSize = textSizeArr[1];
  primaryButtonTextSize = textSizeArr[2];
  controlsTextSize = textSizeArr[3];
  counterTextSize = textSizeArr[4];
}


float keyMultiplier = 10;
boolean nextDebugMove = false;

void keyPressed () {
  if (welcome && keyPressed) {
    setWelcomeFalse = true;
    welcomeIncrement *= 5;
    return;
  }

  if (!allowKeyPressed)
    return;

  switch (key) {
  case 'p':
  case 'P':
    println(inputCubeUserButton.pressed);
    multiplier = 5;
    running = true;
    break;
  case 'k':
  case 'K':
    userCubeFlipped = true;
    break;
  case ' ':
    showFaceNames = !showFaceNames;
    break;
  case 'q':
  case 'Q':
    resetCam();
    break;
  case 'c':
  case 'C':
    Controls.pressed = !Controls.pressed;
    break;
  case 'i':
  case 'I':
    if (executing)
      return;
    inputCube();
    inputCubeUserButton.pressed = inputCube;
    inputCube_mousePressed = true;
    break;
  case '1': 
    scramble();
    break;
  case '2':
    solve();
    break;
  }

  if (executing || turning())
    return;

  if (debug) {
    switch (keyCode) {
    case LEFT: 
      if (debugCount > -1)
        debugReverse = true;
      nextDebugMove = true;
      break;
    case RIGHT: 
      if (debugCount < debugSolveAlgorithm.size() - 1)
        debugCount++;
      debugReverse = false;
      nextDebugMove = true;
      break;
    }
    if (debugCount == -1)
      return;
    if (nextDebugMove)
      debugMove();
    nextDebugMove = false;
  } else {
    switch (keyCode) {
    case UP: 
      Up();
      break;
    case DOWN: 
      Down();
      break;
    case LEFT: 
      Left();
      break;
    case RIGHT: 
      Right();
      break;
    }
  }

  switch(key) {
  case 'y':
  case 'Y':
    flipCubeView_User = true; 
    break;
  case'b': 
    B.start();
    break;
  case'B': 
    Bi.start();
    break;
  case'f': 
    F.start();
    f.pressed = true;
    break;
  case'F': 
    Fi.start();
    break;
  case'u': 
    U.start();
    break;
  case'U': 
    Ui.start();
    break;
  case'd': 
    D.start();
    break;
  case'D': 
    Di.start();
    break;
  case'l': 
    L.start();
    break;
  case'L': 
    Li.start();
    break;
  case'r': 
    R.start();
    break;
  case'R': 
    Ri.start();
    break;
  }
}

boolean turning() {
  if (executing)
    return true;
  Move[] allMoves = {F, U, R, L, D, B, Fi, Ui, Ri, Li, Di, Bi};
  for (Move m : allMoves)
    if (m.animating)
      return true;
  return false;
}

void Up () {
  if (turning())
    return;
  multiplier = keyMultiplier;
  Li.start();
  R.start();
  resetMultiplier();
}

void Down () {
  if (turning())
    return;
  multiplier = keyMultiplier;
  L.start();
  Ri.start();
  resetMultiplier();
}

void Left () {
  if (turning())
    return;
  multiplier = keyMultiplier;
  U.start();
  Di.start();
  resetMultiplier();
}

void Right () {
  if (turning())
    return;
  multiplier = keyMultiplier;
  Ui.start();
  D.start();
  resetMultiplier();
}

void R () {
  input.R();
  for (int i = 0; i < cubies.length; i++)
    if (cubies[i].x == 1)
    {
      PMatrix2D matrix = new PMatrix2D();
      matrix.rotate(HALF_PI);
      matrix.translate(cubies[i].y, cubies[i].z);
      cubies[i].update(round(cubies[i].x), round(matrix.m02), round(matrix.m12));
      cubies[i].updateColorsR();
    }
}

void Ri () {
  input.Ri();
  for (int i = 0; i < cubies.length; i++)
    if (cubies[i].x == 1)
    {
      PMatrix2D matrix = new PMatrix2D();
      matrix.rotate(-HALF_PI);
      matrix.translate(cubies[i].y, cubies[i].z);
      cubies[i].update(round(cubies[i].x), round(matrix.m02), round(matrix.m12));
      cubies[i].updateColorsRi();
    }
}

void L () {
  input.L();
  for (int i = 0; i < cubies.length; i++)
    if (cubies[i].x == -1)
    {
      PMatrix2D matrix = new PMatrix2D();
      matrix.rotate(-HALF_PI);
      matrix.translate(cubies[i].y, cubies[i].z);
      cubies[i].update(round(cubies[i].x), round(matrix.m02), round(matrix.m12));
      cubies[i].updateColorsL();
    }
}

void Li () {
  input.Li();
  for (int i = 0; i < cubies.length; i++)
    if (cubies[i].x == -1)
    {
      PMatrix2D matrix = new PMatrix2D();
      matrix.rotate(HALF_PI);
      matrix.translate(cubies[i].y, cubies[i].z);
      cubies[i].update(round(cubies[i].x), round(matrix.m02), round(matrix.m12));
      cubies[i].updateColorsLi();
    }
}

void D () {
  input.D();
  for (int i = 0; i < cubies.length; i++)
    if (cubies[i].y == 1)
    {
      PMatrix2D matrix = new PMatrix2D();
      matrix.rotate(-HALF_PI);
      matrix.translate(cubies[i].x, cubies[i].z);
      cubies[i].update(round(matrix.m02), round(cubies[i].y), round(matrix.m12));
      cubies[i].updateColorsD();
    }
}

void Di () {
  input.Di();
  for (int i = 0; i < cubies.length; i++)
    if (cubies[i].y == 1)
    {
      PMatrix2D matrix = new PMatrix2D();
      matrix.rotate(HALF_PI);
      matrix.translate(cubies[i].x, cubies[i].z);
      cubies[i].update(round(matrix.m02), round(cubies[i].y), round(matrix.m12));
      cubies[i].updateColorsDi();
    }
}

void U () {
  input.U();
  for (int i = 0; i < cubies.length; i++)
    if (cubies[i].y == -1)
    {
      PMatrix2D matrix = new PMatrix2D();
      matrix.rotate(HALF_PI);
      matrix.translate(cubies[i].x, cubies[i].z);
      cubies[i].update(round(matrix.m02), round(cubies[i].y), round(matrix.m12));
      cubies[i].updateColorsU();
    }
}

void Ui () {
  input.Ui();
  for (int i = 0; i < cubies.length; i++)
    if (cubies[i].y == -1)
    {
      PMatrix2D matrix = new PMatrix2D();
      matrix.rotate(-HALF_PI);
      matrix.translate(cubies[i].x, cubies[i].z);
      cubies[i].update(round(matrix.m02), round(cubies[i].y), round(matrix.m12));
      cubies[i].updateColorsUi();
    }
}

void B () {
  input.B();
  for (int i = 0; i < cubies.length; i++)
    if (cubies[i].z == -1)
    {
      PMatrix2D matrix = new PMatrix2D();
      matrix.rotate(-HALF_PI);
      matrix.translate(cubies[i].x, cubies[i].y);
      cubies[i].update(round(matrix.m02), round(matrix.m12), round(cubies[i].z));
      cubies[i].updateColorsB();
    }
}

void Bi () {
  input.Bi();
  for (int i = 0; i < cubies.length; i++)
    if (cubies[i].z == -1)
    {
      PMatrix2D matrix = new PMatrix2D();
      matrix.rotate(HALF_PI);
      matrix.translate(cubies[i].x, cubies[i].y);
      cubies[i].update(round(matrix.m02), round(matrix.m12), round(cubies[i].z));
      cubies[i].updateColorsBi();
    }
}

void F () {
  input.F();
  for (int i = 0; i < cubies.length; i++)
    if (cubies[i].z == 1)
    {
      PMatrix2D matrix = new PMatrix2D();
      matrix.rotate(HALF_PI);
      matrix.translate(cubies[i].x, cubies[i].y);
      cubies[i].update(round(matrix.m02), round(matrix.m12), round(cubies[i].z));
      cubies[i].updateColorsF();
    }
}

void Fi () {
  input.Fi();
  for (int i = 0; i < cubies.length; i++)
    if (cubies[i].z == 1)
    {
      PMatrix2D matrix = new PMatrix2D();
      matrix.rotate(-HALF_PI);
      matrix.translate(cubies[i].x, cubies[i].y);
      cubies[i].update(round(matrix.m02), round(matrix.m12), round(cubies[i].z));
      cubies[i].updateColorsFi();
    }
}


public class UserButton {

  String name = "", type = "";
  float buttonX, buttonY, buttonWidth, buttonHeight, buttonRadius, buttonLength;
  color defaultButtonColor = color (155, 15, 230), buttonColor = color (155, 15, 230), 
    alternateButtonColor = color (242, 98, 35), originalButtonColor, alternateButtonColor2 = color(39, 180, 102), 
    alternateButtonColor3 = color(21, 118, 187), alternateButtonColor4 = color(16, 160, 197);
  boolean pressed = false, active = false, suspend = false;

  public UserButton(String name) {
    this.name = name;
  }

  public String toString() {
    return this.name;
  }

  public void activate() {
    this.active = true;
  }

  public void deactivate() {
    this.active = false;
  }

  public void suspend() {
    this.suspend = true;
  }

  public void unsuspend () {
    this.suspend = false;
  }

  public void setup() {
    textSize(primaryButtonTextSize);
    switch(name) {
    case scrambleName :
      type = rect;
      buttonX = .0075 * displayWidth;
      buttonY = buttonX;
      buttonWidth = 1.20 * textWidth(scrambleName);
      buttonHeight = 1.20 * textHeight(scrambleName);
      break;
    case solveName :
      type = rect;
      buttonWidth = 0.9 * scrambleUserButton.buttonWidth;
      buttonHeight = 1.05 * textHeight(solveName);
      buttonX = .9925 * displayWidth - buttonWidth;
      buttonY = .0075 * displayWidth;
      break;
    case inputCubeName :
      type = rect;
      buttonWidth = 1.20 * textWidth(inputCubeName);
      buttonHeight = 1.20 * textHeight(inputCubeName);
      buttonX = .0075 * displayWidth;
      buttonY = displayHeight - (buttonHeight + buttonX);
      break;
    case controlsName :
      type = rect;
      buttonWidth = 0.9 * scrambleUserButton.buttonWidth;
      buttonHeight = 1.05 * textHeight(controlsName);
      buttonX = .9925 * displayWidth - buttonWidth;
      buttonY = displayHeight - (buttonHeight + .0075 * displayWidth);
      controlsX = 0.688 * displayWidth;
      controlsY = 0.234 * displayHeight;
      controlsWidth = 0.278 * displayWidth;
      controlsHeight = 0.656 * displayHeight;
      controlsText_X = 0.698 * displayWidth;
      controlsText_Y = 0.862 * displayHeight;
      break;
    case homeName: 
      type = square;
      buttonX = 0.478 * displayWidth;
      buttonY = 0.881 * displayHeight;
      buttonLength = .044 * displayWidth;
      buttonWidth = buttonLength;
      buttonHeight = buttonLength;
      break;
    case cancelName:
      type = square;
      buttonLength = .0146 * displayWidth;
      buttonWidth = buttonLength;
      buttonHeight = buttonLength;
      buttonX = controlsX + controlsWidth - buttonWidth;
      buttonY = controlsY;
      cancelLineX = buttonX;
      cancelLineY = buttonY;
      break;
    case leftName:
      type = square;
      buttonLength = .175 * controlsWidth;
      buttonWidth = buttonLength;
      buttonHeight = buttonLength;
      buttonX = controlsX + (controlsWidth - 3.0 * buttonLength) / 4.0;
      buttonY = controlsY + buttonLength + 0.1 * controlsHeight;
      break;
    case rightName:
      type = square; 
      buttonLength = left.buttonLength;
      buttonWidth = buttonLength;
      buttonHeight = buttonLength;
      buttonX = controlsX + 2.0 * buttonLength + 3.0 * (controlsWidth - 3.0 * buttonLength) / 4.0;
      buttonY = left.buttonY;
      break;
    case upName:
      type = square;
      buttonLength = left.buttonLength;
      buttonWidth = buttonLength;
      buttonHeight = buttonLength;
      buttonX = controlsX + buttonLength + 2.0 * (controlsWidth - 3.0 * buttonLength) / 4.0;
      buttonY = controlsY + 0.05 * controlsHeight;
      break;
    case downName:
      type = square; 
      buttonLength = left.buttonLength;
      buttonWidth = buttonLength;
      buttonHeight = buttonLength;
      buttonX = up.buttonX;
      buttonY = controlsY + 2.0 * buttonLength + 0.15 * controlsHeight;
      break;
    case middleName:
      type = square; 
      buttonLength = left.buttonLength;
      buttonWidth = buttonLength;
      buttonHeight = buttonLength;
      buttonX = up.buttonX;
      buttonY = (down.buttonY + up.buttonY + up.buttonHeight - buttonHeight) / 2.0;
      break;
    case fName:
      type = rect; 
      buttonLength = 0.225 * (controlsText_Y - (down.buttonY + down.buttonLength));
      buttonWidth = buttonLength;
      buttonHeight = buttonLength;
      buttonX = controlsX + (controlsWidth - 6.0 * buttonLength) / 7.0;
      buttonY = down.buttonY + down.buttonLength + 0.5 * (controlsText_Y - (down.buttonY + down.buttonLength)) 
        - 1.25 * buttonLength;
      break;
    case fiName:
      type = rect; 
      buttonLength = f.buttonLength;
      buttonWidth = buttonLength;
      buttonHeight = buttonLength;
      buttonX = f.buttonX;
      buttonY = f.buttonY + 1.25 * f.buttonLength;
      break;
    case rName:
      type = rect; 
      buttonLength = f.buttonLength;
      buttonWidth = buttonLength;
      buttonHeight = buttonLength;
      buttonX = controlsX + buttonLength + 2.0 * (f.buttonX - controlsX);
      buttonY = f.buttonY;
      break;
    case riName:
      type = rect; 
      buttonLength = f.buttonLength;
      buttonWidth = buttonLength;
      buttonHeight = buttonLength;
      buttonX = r.buttonX;
      buttonY = fi.buttonY;
      break;
    case uName:
      type = rect; 
      buttonLength = f.buttonLength;
      buttonWidth = buttonLength;
      buttonHeight = buttonLength;
      buttonX = controlsX + 2.0 * buttonLength + 3.0 * (f.buttonX - controlsX);
      buttonY = f.buttonY;
      break;
    case uiName:
      type = rect; 
      buttonLength = f.buttonLength;
      buttonWidth = buttonLength;
      buttonHeight = buttonLength;
      buttonX = u.buttonX;
      buttonY = fi.buttonY;
      break;
    case lName:
      type = rect; 
      buttonLength = f.buttonLength;
      buttonWidth = buttonLength;
      buttonHeight = buttonLength;
      buttonX = controlsX + 3.0 * buttonLength + 4.0 * (f.buttonX - controlsX);
      buttonY = f.buttonY;
      break;
    case liName:
      type = rect; 
      buttonLength = f.buttonLength;
      buttonWidth = buttonLength;
      buttonHeight = buttonLength;
      buttonX = l.buttonX;
      buttonY = fi.buttonY;
      break;
    case dName:
      type = rect; 
      buttonLength = f.buttonLength;
      buttonWidth = buttonLength;
      buttonHeight = buttonLength;
      buttonX = controlsX + 4.0 * buttonLength + 5.0 * (f.buttonX - controlsX);
      buttonY = f.buttonY;
      break;
    case diName:
      type = rect; 
      buttonLength = f.buttonLength;
      buttonWidth = buttonLength;
      buttonHeight = buttonLength;
      buttonX = d.buttonX;
      buttonY = fi.buttonY;
      break;
    case bName:
      type = rect; 
      buttonLength = f.buttonLength;
      buttonWidth = buttonLength;
      buttonHeight = buttonLength;
      buttonX = controlsX + 5.0 * buttonLength + 6.0 * (f.buttonX - controlsX);
      buttonY = f.buttonY;
      break;
    case biName:
      type = rect; 
      buttonLength = f.buttonLength;
      buttonWidth = buttonLength;
      buttonHeight = buttonLength;
      buttonX = b.buttonX;
      buttonY = fi.buttonY;
      break;
    case pieceOption1Name:
      type = option;
      float f = 0.40, showOptions_PiecesSpace = f * inputCubeUserButton.buttonWidth, 
        showOptions_PiecesWidth = (inputCubeUserButton.buttonWidth - showOptions_PiecesSpace) / 2.0, 
        showOptions_PiecesX = inputCubeUserButton.buttonX, showOptions_PiecesY = (displayHeight - 4.2 * showOptions_PiecesWidth) / 2.0;
      buttonLength = showOptions_PiecesWidth;
      showOptions_PiecesWidthFloat = buttonLength;
      buttonWidth = buttonLength;
      buttonHeight = buttonLength;
      buttonX = showOptions_PiecesX;
      showOptions_PiecesX_Float = showOptions_PiecesX;
      buttonY = showOptions_PiecesY;
      showOptions_PiecesY_Float = showOptions_PiecesY;
      break;
    case pieceOption2Name:
      type = option;
      buttonLength = showOptions_PiecesWidthFloat;
      buttonWidth = buttonLength;
      buttonHeight = buttonLength;
      buttonX = showOptions_PiecesX_Float + buttonLength;
      buttonY = showOptions_PiecesY_Float;
      break;
    case pieceOption3Name:
      type = option;
      buttonLength = showOptions_PiecesWidthFloat;
      buttonWidth = buttonLength;
      buttonHeight = buttonLength;
      buttonX = showOptions_PiecesX_Float;
      buttonY = showOptions_PiecesY_Float + buttonLength;
      break;
    case pieceOption4Name:
      type = option;
      buttonLength = showOptions_PiecesWidthFloat;
      buttonWidth = buttonLength;
      buttonHeight = buttonLength;
      buttonX = showOptions_PiecesX_Float + buttonLength;
      buttonY = showOptions_PiecesY_Float + buttonLength;
      break;
    case pieceOption5Name:
      type = option;
      buttonLength = showOptions_PiecesWidthFloat;
      buttonWidth = buttonLength;
      buttonHeight = buttonLength;
      buttonX = showOptions_PiecesX_Float;
      buttonY = showOptions_PiecesY_Float + 2 * buttonLength;
      break;
    case pieceOption6Name:
      type = option;
      buttonLength = showOptions_PiecesWidthFloat;
      buttonWidth = buttonLength;
      buttonHeight = buttonLength;
      buttonX = showOptions_PiecesX_Float + buttonLength;
      buttonY = showOptions_PiecesY_Float + 2 * buttonLength;
      break;
    case pieceOption7Name:
      type = option;
      buttonLength = showOptions_PiecesWidthFloat;
      buttonWidth = buttonLength;
      buttonHeight = buttonLength;
      buttonX = showOptions_PiecesX_Float;
      buttonY = showOptions_PiecesY_Float + 3 * buttonLength;
      break;
    case pieceOption8Name:
      type = option;
      buttonLength = showOptions_PiecesWidthFloat;
      buttonWidth = buttonLength;
      buttonHeight = buttonLength;
      buttonX = showOptions_PiecesX_Float + buttonLength;
      buttonY = showOptions_PiecesY_Float + 3 * buttonLength;
      break;
    case colorOption1Name:
      type = option;
      float g = 0.30, showOptions_ColorsSpace = g * inputCubeUserButton.buttonWidth, 
        showOptions_ColorsWidth = (inputCubeUserButton.buttonWidth - showOptions_ColorsSpace) / 2.0, 
        showOptions_ColorsX = inputCubeUserButton.buttonX, showOptions_ColorsY = (displayHeight - 3 * showOptions_ColorsWidth) / 2.0;
      buttonLength = showOptions_ColorsWidth;
      buttonWidth = buttonLength;
      buttonHeight = buttonLength;
      buttonX = showOptions_ColorsX;
      buttonY = showOptions_ColorsY;
      break;
    case colorOption2Name:
      type = option;
      buttonLength = colorOption1.buttonLength;
      buttonWidth = buttonLength;
      buttonHeight = buttonLength;
      buttonX = colorOption1.buttonX;
      buttonY = colorOption1.buttonY + buttonLength;
      break;
    case colorOption3Name:
      type = option;
      buttonLength = colorOption1.buttonLength;
      buttonWidth = buttonLength;
      buttonHeight = buttonLength;
      buttonX = colorOption1.buttonX;
      buttonY = colorOption1.buttonY + 2 * buttonLength;
      break;
    case doneButtonName:
      type = rect;
      setTextSize(doneButtonName);
      buttonX = 0.475 * (displayWidth - textWidth(doneButtonName));
      buttonY = 0.17 * displayHeight;
      buttonWidth = 1.20 * textWidth(doneButtonName);
      buttonHeight = 1.20 * textHeight(doneButtonName);
      break;
    }
  }

  public void draw() {
    if (this.name.equals(doneButtonName) && !flipCubeView)
      return;
    cam.beginHUD();
    if (insideButton())
      this.updateButtonColor();
    else if (!pressed)
      this.resetButtonColor();
    this.drawButton();
    mouseClicked();
    cam.endHUD();
  }

  void mouseClicked() {
    if (mouseHoldCount > mouseHoldThreshold || mouseButton == RIGHT)
      return;
    if (mousePressed && mousePressedActive) {
      if (insideButton()) {
        if (name.equals(inputCubeName) && executing)
          return;
        pressed = true;
        switch(name) {
        case scrambleName :
          scramble();
          break;
        case solveName :
          solve();
          break;
        case homeName :  
          resetCam();
          goingHome = true;
          break;
        case inputCubeName :
          if (executing)
            return;
          inputCube();
          pressed = inputCube;
          inputCube_mousePressed = true;
          break;
        case cancelName :
          Controls.pressed = false;
          break;
        case leftName : 
          Left();
          pressed = false;
        case upName : 
          Up();
          pressed = false;
          break;
        case rightName : 
          Right();
          pressed = false;
        case downName : 
          Down();
          pressed = false;
          break;
        case middleName : 
          if (!firstClick_Middle)
            return;
          showFaceNames = !showFaceNames;
          firstClick_Middle = false;
          break;
        case fName:
          pressed = false;
          if (executing || turning())
            return;
          F.start();
          break;
        case fiName:
          pressed = false;
          if (executing || turning())
            return;
          Fi.start();
          break;
        case rName:
          pressed = false;
          if (executing || turning())
            return;
          R.start();
          break;
        case riName:
          pressed = false;
          if (executing || turning())
            return;
          Ri.start();
          break;
        case uName:
          pressed = false;
          if (executing || turning())
            return;
          U.start();
          break;
        case uiName:
          pressed = false;
          if (executing || turning())
            return;
          Ui.start();
          break;
        case lName:
          pressed = false;
          if (executing || turning())
            return;
          L.start();
          break;
        case liName:
          pressed = false;
          if (executing || turning())
            return;
          Li.start();
          break;
        case dName:
          pressed = false;
          if (executing || turning())
            return;
          D.start();
          break;
        case diName:
          pressed = false;
          if (executing || turning())
            return;
          Di.start();
          break;
        case bName:
          pressed = false;
          if (executing || turning())
            return;
          B.start();
          break;
        case biName:
          pressed = false;
          if (executing || turning())
            return;
          Bi.start();
          break;
        case pieceOption1Name:
          if (promptUser_Position == false || cubeOptions.size() < 1)
            return;
          pressed = false;
          cubeOptionRemove(0);
          promptUser_Position = !promptUser_Position;
          mousePressedActive = false;
          if (cubeOptions.size() == 3) {
            unhighlight(7);
            highlight(7, 0);
          }
          break;
        case pieceOption2Name:
          if (promptUser_Position == false || cubeOptions.size() < 2)
            return;
          pressed = false;
          cubeOptionRemove(1);
          promptUser_Position = !promptUser_Position;
          mousePressedActive = false;
          if (cubeOptions.size() == 3) {
            unhighlight(7);
            highlight(7, 0);
          }
          break;
        case pieceOption3Name:
          if (promptUser_Position == false || cubeOptions.size() < 3)
            return;
          pressed = false;
          cubeOptionRemove(2);
          promptUser_Position = !promptUser_Position;
          mousePressedActive = false;
          if (cubeOptions.size() == 3) {
            unhighlight(7);
            highlight(7, 0);
          }
          break;
        case pieceOption4Name:
          if (promptUser_Position == false || cubeOptions.size() < 4)
            return;
          pressed = false;
          cubeOptionRemove(3);
          promptUser_Position = !promptUser_Position;
          mousePressedActive = false;
          if (cubeOptions.size() == 3) {
            unhighlight(7);
            highlight(7, 0);
          }
          break;
        case pieceOption5Name:
          if (promptUser_Position == false || cubeOptions.size() < 5)
            return;
          pressed = false;
          cubeOptionRemove(4);
          promptUser_Position = !promptUser_Position;
          mousePressedActive = false;
          break;
        case pieceOption6Name:
          if (promptUser_Position == false || cubeOptions.size() < 6)
            return;
          pressed = false;
          cubeOptionRemove(5);
          promptUser_Position = !promptUser_Position;
          mousePressedActive = false;
          break;
        case pieceOption7Name:
          pressed = false;
          if (promptUser_Position == false || cubeOptions.size() < 7)
            return;
          cubeOptionRemove(6);
          promptUser_Position = !promptUser_Position;
          mousePressedActive = false;
          break;
        case pieceOption8Name:
          if (promptUser_Position == false || cubeOptions.size() < 8)
            return;
          pressed = false;
          cubeOptionRemove(7);
          promptUser_Position = !promptUser_Position;
          mousePressedActive = false;
          break;
        case colorOption1Name: 
          selectedColor = selectedCube.faceColors()[0];
          pressed = false;
          promptUser_Position = !promptUser_Position;
          mousePressedActive = false;
          updateInputCube();
          break;
        case colorOption2Name: 
          selectedColor = selectedCube.faceColors()[1];
          pressed = false;
          promptUser_Position = !promptUser_Position;
          mousePressedActive = false;
          updateInputCube();
          break;
        case colorOption3Name: 
          selectedColor = selectedCube.faceColors()[2];
          pressed = false;
          promptUser_Position = !promptUser_Position;
          mousePressedActive = false;
          updateInputCube();
          break;
        case doneButtonName:
          userCubeFlipped = true;
          pressed = false;
          break;
        }
      }
    }
  }

  public void drawButton() {
    stroke(0);
    strokeWeight(3);
    fill(buttonColor);
    switch (type) {
    case rect: 
      rect(buttonX, buttonY, buttonWidth, buttonHeight);
      fill(255);
      setTextSize(name);
      text(name, buttonX + (buttonWidth - textWidth(name)) / 2.0, buttonY + (buttonHeight - textHeight(name)) / 2.0, buttonWidth, buttonHeight);
      break;
    case square:
      if (name.equals(homeName) && atHome) // if the cube is atHome then the homeButton will not appear
        return;
      switch (name) {
      case homeName:
      case leftName:
      case rightName:
      case upName:
      case downName:
      case middleName:
        noFill();
        noStroke();
        break;
      }
      square(buttonX, buttonY, buttonLength);
      break;
    case option:
      int check = -1;
      switch (name) {
      case pieceOption1Name: 
        check = 1;
        break;
      case pieceOption2Name:
        check = 2;
        break;
      case pieceOption3Name:
        check = 3;
        break;
      case pieceOption4Name:
        check = 4;
        break;
      case pieceOption5Name:
        check = 5;
        break;
      case pieceOption6Name:
        check = 6;
        break;
      case pieceOption7Name:
        check = 7;
        break;
      case pieceOption8Name:
        check = 8;
        break;
      }
      if (cubeOptions.size() < check) 
        break;
      noFill();
      if (changeColor())
        fill(black, 155);
      square(buttonX, buttonY, buttonLength);
      break;
    }
    drawIcon();
    active = true;
  }

  void drawIcon() {
    switch(this.name) {
    case homeName:
      if (!atHome)
        drawHomeIcon();
    case cancelName:
      drawCancelIcon();
      break;
    case leftName:
      drawLeftButtonIcon();
      break;
    case upName:
      drawUpButtonIcon();
      break;
    case rightName:
      drawRightButtonIcon();
      break;
    case downName:
      drawDownButtonIcon();
      break;
    case middleName:
      drawMiddleButtonIcon();
      break;
    case pieceOption1Name:
      if (cubeOptions.size() >= 1)
        cubeDraw(buttonX + buttonLength / 2.0, buttonY + buttonLength / 2.0, toColor(cubeOptions.get(0).faceColors()[0]), toColor(cubeOptions.get(0).faceColors()[1]), toColor(cubeOptions.get(0).faceColors()[2]));
      break;
    case pieceOption2Name:
      if (cubeOptions.size() >= 2)
        cubeDraw(buttonX + buttonLength / 2.0, buttonY + buttonLength / 2.0, toColor(cubeOptions.get(1).faceColors()[0]), toColor(cubeOptions.get(1).faceColors()[1]), toColor(cubeOptions.get(1).faceColors()[2]));
      break;
    case pieceOption3Name:
      if (cubeOptions.size() >= 3)
        cubeDraw(buttonX + buttonLength / 2.0, buttonY + buttonLength / 2.0, toColor(cubeOptions.get(2).faceColors()[0]), toColor(cubeOptions.get(2).faceColors()[1]), toColor(cubeOptions.get(2).faceColors()[2]));
      break;
    case pieceOption4Name:
      if (cubeOptions.size() >= 4)
        cubeDraw(buttonX + buttonLength / 2.0, buttonY + buttonLength / 2.0, toColor(cubeOptions.get(3).faceColors()[0]), toColor(cubeOptions.get(3).faceColors()[1]), toColor(cubeOptions.get(3).faceColors()[2]));
      break;
    case pieceOption5Name:
      if (cubeOptions.size() >= 5)
        cubeDraw(buttonX + buttonLength / 2.0, buttonY + buttonLength / 2.0, toColor(cubeOptions.get(4).faceColors()[0]), toColor(cubeOptions.get(4).faceColors()[1]), toColor(cubeOptions.get(4).faceColors()[2]));
      break;
    case pieceOption6Name:
      if (cubeOptions.size() >= 6)
        cubeDraw(buttonX + buttonLength / 2.0, buttonY + buttonLength / 2.0, toColor(cubeOptions.get(5).faceColors()[0]), toColor(cubeOptions.get(5).faceColors()[1]), toColor(cubeOptions.get(5).faceColors()[2]));
      break;
    case pieceOption7Name:
      if (cubeOptions.size() >= 7)
        cubeDraw(buttonX + buttonLength / 2.0, buttonY + buttonLength / 2.0, toColor(cubeOptions.get(6).faceColors()[0]), toColor(cubeOptions.get(6).faceColors()[1]), toColor(cubeOptions.get(6).faceColors()[2]));
      break;
    case pieceOption8Name:
      if (cubeOptions.size() == 8)
        cubeDraw(buttonX + buttonLength / 2.0, buttonY + buttonLength / 2.0, toColor(cubeOptions.get(7).faceColors()[0]), toColor(cubeOptions.get(7).faceColors()[1]), toColor(cubeOptions.get(7).faceColors()[2]));
      break;
    case colorOption1Name:
      fill(toColor(selectedCube.faceColors()[0]));
      float f = 0.8;
      square(buttonX + buttonLength * ((1.0 - f) / 2.0), buttonY + buttonLength * ((1.0 - f) / 2.0), f * buttonLength);
      break;
    case colorOption2Name:
      fill(toColor(selectedCube.faceColors()[1]));
      float g = 0.8;
      square(buttonX + buttonLength * ((1.0 - g) / 2.0), buttonY + buttonLength * ((1.0 - g) / 2.0), g * buttonLength);
      break;
    case colorOption3Name:
      fill(toColor(selectedCube.faceColors()[2]));
      float h = 0.8;
      square(buttonX + buttonLength * ((1.0 - h) / 2.0), buttonY + buttonLength * ((1.0 - h) / 2.0), h * buttonLength);
      break;
    }
  }

  boolean changeColor () {
    return this.insideButton() || this.pressed;
  }

  public void updateButtonColor() {
    buttonColor = black;
  }

  public void resetButtonColor() {
    if (this.type.equals(square))
      buttonColor = originalButtonColor;
    else
      buttonColor = defaultButtonColor;
  }

  boolean insideButton() {
    float x = buttonX, y = buttonY;
    if (this.type.equals(circle)) {
      x -= (0.5 * buttonWidth);
      y -= (0.5 * buttonHeight);
    }
    if (mouseX >= x && mouseX <= x + buttonWidth && mouseY >= y && mouseY <= y + buttonHeight)
      return true;
    return false;
  }

  boolean insideButton(float x, float y) {
    if (x >= buttonX && x <= buttonX + buttonWidth && y >= buttonY && y <= buttonY + buttonHeight)
      return true;
    return false;
  }

  // User Button Class END //
}

int mouseHoldCount = 0, mouseHoldThreshold = 30;

void mouseReleased() {
  mouseHoldCount = 0;
}

float cancelLineX = 0, cancelLineY = 0;

void drawCancelIcon() {
  if (Controls.pressed == false)
    return;
  stroke(white);
  if (cancel.insideButton())
    strokeWeight(3.62);
  else
    strokeWeight(2.22);
  line(cancelLineX, cancelLineY, cancelLineX + cancel.buttonLength, cancelLineY + cancel.buttonLength);
  line(cancelLineX, cancelLineY + cancel.buttonLength, cancelLineX + cancel.buttonLength, cancelLineY);
  strokeWeight(3.4);
  stroke(black);
  fill(red);
  square(cancel.buttonX, cancel.buttonY, cancel.buttonWidth);
}

void drawHomeIcon() {
  fill(Home.alternateButtonColor);
  stroke(black);
  if (Home.insideButton()) 
    fill(Home.alternateButtonColor2);
  float squareLength = 0.59 * Home.buttonLength, squareX = Home.buttonX + (Home.buttonLength - squareLength) / 2.0, 
    squareY = Home.buttonY + Home.buttonLength - squareLength;
  square(squareX, squareY, squareLength); 
  float aX = Home.buttonX + Home.buttonLength / 2.0, 
    aY = Home.buttonY, bX = squareX, bY = squareY, cX = squareX + squareLength, cY = squareY;
  triangle(aX, aY, bX, bY, cX, cY);
  float rectWidth = 0.4 * squareLength, rectX = squareX + (squareLength - rectWidth) / 2.0, 
    rectHeight = 0.55 * squareLength, rectY = squareY + 0.65 * (squareLength - rectHeight);
  rect(rectX, rectY, rectWidth, rectHeight);
}

int timeCountLeft = 0;
boolean leftIconGrow = false;

void drawLeftButtonIcon () {
  strokeWeight(3.62);
  fill(orange);
  stroke(black);
  float aX = left.buttonX, aY = left.buttonY + left.buttonLength / 2.0, 
    bX = left.buttonX + left.buttonLength, bY = left.buttonY, 
    cX = bX, cY = left.buttonY + left.buttonLength, shiftLength = 0;
  if (left.changeColor()) {
    float shiftAngle = (float) Math.atan(45/22);
    if (timeCountLeft % 40 == 0)
      leftIconGrow = !leftIconGrow;
    if (leftIconGrow == true)
      shiftLength = 31.5;
    else
      shiftLength = 27.5;
    float horizShift = shiftLength * (float) Math.sin(shiftAngle/2), vertShift = shiftLength * (float) Math.cos(shiftAngle/2);
    triangle(aX + shiftLength, aY, bX - horizShift, bY + vertShift, cX - horizShift, cY - vertShift);
    if (timeCountLeft == 10000000)
      timeCountLeft = 0;
    else
      timeCountLeft++;
  } 
  triangle(aX, aY, bX, bY, cX, cY);
}

int timeCountUp = 0;
boolean upIconGrow = false;

void drawUpButtonIcon () {
  strokeWeight(3.62);
  fill(orange);
  stroke(black);
  float aX = up.buttonX, aY = up.buttonY + up.buttonLength, 
    bX = up.buttonX + up.buttonLength / 2.0, bY = up.buttonY, 
    cX = up.buttonX + up.buttonLength, cY = up.buttonY + up.buttonLength, shiftLength = 0;
  if (up.changeColor()) {
    if (timeCountUp % 40 == 0)
      upIconGrow = !upIconGrow;
    if (upIconGrow == true)
      shiftLength = 31.5;
    else
      shiftLength = 27.5;
    float shiftAngle = (float) Math.atan(2);
    float horizShift = shiftLength * (float) Math.cos(shiftAngle / 2.0), vertShift = shiftLength * (float) Math.sin(shiftAngle / 2.0);
    triangle(aX + horizShift, aY - vertShift, bX, bY + shiftLength, cX - horizShift, cY - vertShift);
    if (timeCountLeft == 10000000)
      timeCountUp = 0;
    else
      timeCountUp++;
  } 
  triangle(aX, aY, bX, bY, cX, cY);
}

int timeCountRight = 0;
boolean rightIconGrow = false;

void drawRightButtonIcon () {
  strokeWeight(3.62);
  fill(orange);
  stroke(black);
  float aX = right.buttonX, aY = right.buttonY, 
    bX = right.buttonX, bY = right.buttonY + right.buttonLength, 
    cX = right.buttonX + right.buttonLength, cY = right.buttonY + right.buttonLength / 2.0, shiftLength = 0;
  if (right.changeColor()) {
    float shiftAngle = (float) Math.atan(45/22);
    if (timeCountRight % 40 == 0)
      rightIconGrow = !rightIconGrow;
    if (rightIconGrow == true)
      shiftLength = 31.5;
    else
      shiftLength = 27.5;
    float horizShift = shiftLength * (float) Math.sin(shiftAngle/2), vertShift = shiftLength * (float) Math.cos(shiftAngle/2);
    triangle(aX + horizShift, aY + vertShift, bX + horizShift, bY - vertShift, cX - shiftLength, cY);
    if (timeCountLeft == 10000000)
      timeCountRight = 0;
    else
      timeCountRight++;
  } 
  triangle(aX, aY, bX, bY, cX, cY);
}

int timeCountDown = 0;
boolean downIconGrow = false;

void drawDownButtonIcon () {
  strokeWeight(3.62);
  fill(orange);
  stroke(black);
  float aX = down.buttonX, aY = down.buttonY, 
    bX = down.buttonX + down.buttonLength / 2.0, bY = down.buttonY + down.buttonLength, 
    cX = down.buttonX + down.buttonLength, cY = down.buttonY, shiftLength = 0;
  if (down.changeColor()) {
    if (timeCountDown % 40 == 0)
      downIconGrow = !downIconGrow;
    if (downIconGrow == true)
      shiftLength = 31.5;
    else
      shiftLength = 27.5;
    float shiftAngle = (float) Math.atan(2);
    float horizShift = shiftLength * (float) Math.cos(shiftAngle / 2.0), vertShift = shiftLength * (float) Math.sin(shiftAngle / 2.0);
    triangle(aX + horizShift, aY + vertShift, bX, bY - shiftLength, cX - horizShift, cY + vertShift);
    if (timeCountLeft == 10000000)
      timeCountDown = 0;
    else
      timeCountDown++;
  } 
  triangle(aX, aY, bX, bY, cX, cY);
}

String middleButtonStatus() {
  if (showFaceNames)
    return "ON";
  return "OFF";
}

int timeCountMiddle = 0;
boolean middleIconGrow = false;

void drawMiddleButtonIcon () {
  if (timeCountMiddle % 40 == 0)
    middleIconGrow = !middleIconGrow;
  fill (orange);
  stroke(black);
  strokeWeight(3.62);
  float x = (left.buttonX + left.buttonLength + right.buttonX) / 2.0, y = (up.buttonY + up.buttonLength + down.buttonY) / 2.0;
  circle (x, y, middle.buttonLength);
  if (showFaceNames)
    fill (yellow);
  float k = 0.65;
  if (middle.insideButton() && middleIconGrow)
    k = 0.75;
  circle (x, y, k * middle.buttonLength);
  fill(black);
  textSize(0.30 * titleTextSize);
  text(middleButtonStatus(), x - textWidth (middleButtonStatus()) / 2.0, y + textHeight (middleButtonStatus()) / 2.0);
  if (timeCountMiddle == 100000)
    timeCountMiddle = 0;
  else
    timeCountMiddle++;
}


void showFaceNames() {
  if (!showFaceNames) 
    return;
  fill(emerald);
  showFaceNames("F");
  rotateX((float)(Math.PI/2));
  showFaceNames("U");
  rotateX((float)(-Math.PI));
  showFaceNames("D");
  rotateX((float)(Math.PI/2));
  rotateY((float)(Math.PI/2));
  showFaceNames("R");
  rotateY((float)(Math.PI/2));
  showFaceNames("B");
  rotateY((float)(Math.PI/2));
  showFaceNames("L");
}

void showFaceNames(String faceName) {
  float d = 3.25;
  push();
  textSize(0.025 * titleTextSize);
  text(faceName, - (textWidth(faceName) / 2.0), textHeight(faceName) / 4.0, d);
  pop();
}


void solve () {
  if (solve || inputCubeUserButton.pressed)
    return;
  if (input.isSolved()) {
    showSolveAlert = true;
    return;
  }
  Controls.pressed = false;
  multiplier = 5;
  if (scramble) 
    solveWhileScrambling();
  else {
    executing = true;
    keepCounter = false;
    solve = true;
    input.solve();
    input.optimizeAlgorithmList();
    solveAlgorithm = input.listOfAlgorithms;
    animationSetup();
    running = true;
  }
}

boolean showSolveWhileScramblingMessage = false;

void solveWhileScrambling() {
  showSolveWhileScramblingMessage = true;
}

boolean showScrambleWhileSolvingMessage = false;

void scrambleWhileSolving() {
  showScrambleWhileSolvingMessage = true;
}

void scramble() {
  if (scramble || scrambling || inputCubeUserButton.pressed)
    return;
  multiplier = 5;
  if (solve)
    scrambleWhileSolving();
  else {
    scrambling = true;
    moves = new ArrayList<Move>();
    input.resetLists();
    showCounter = false;
    scramble = true;
    executing = true;
    randomizeMoveList((int)(((20 * Math.random()) + 10)));
    scrambleAlgorithm = moves;
    animationSetup();
    running = true;
    keepCounter = false;
  }
}

boolean alertShowing() {
  if (showSolveAlert || showSolveWhileScramblingMessage || showScrambleWhileSolvingMessage)
    return true;
  return false;
}

float bannerX, bannerY, bannerWidth, bannerHeight;

void title() {
  if (rotating || alertShowing())
    showTitle = false;
  else
    showTitle = true;
  textSize(titleTextSize);
  fill(255);
  float titleX = (displayWidth - textWidth(title)) / 2, titleY = 0.15 * displayHeight;
  bannerX = titleX;
  bannerY = titleY;
  bannerWidth = textWidth(title);
  bannerHeight = textHeight(title);
  if (showTitle)
    text(title, titleX, titleY);
}

float counterDiameter = 0, counterCenterX;

void counter() {
  if (running && moves.size() > 0) {
    float x = 0.842 * displayWidth, y = 0.5 * displayHeight, d = 0.117 * displayWidth;
    counterDiameter = d;   
    counterCenterX = x;
    fill(black);
    circle(x, y, d);
    String moveNum = "" + (counter + 1);
    setCounterTextSize();
    fill(white);
    text (moveNum, x - textWidth(moveNum) / 2.0, y + textHeight(maxCount) / 2.0);
  }
}

void setCounterTextSize() {
  textSize(counterTextSize);
}

void counter(int counter) {
  if (keepTimer < keepTime) {
    float x = 0.842 * displayWidth, y = 0.5 * displayHeight, d = 0.117 * displayWidth;
    counterDiameter = d;    
    fill(black);
    circle(x, y, d);
    String moveNum = "" + (counter + 1);
    setCounterTextSize();
    fill(white);
    text (moveNum, x - textWidth(moveNum) / 2.0, y + textHeight(maxCount) / 2.0);
  }
}

final String maxMove = "ZZ";
float moveBoxSideLength = 0;

void showMove() {
  if (showMove && keepTimer < keepTime) {
    if (currentMove != null && currentMove.toString() != null) {
      float x = displayWidth - (counterCenterX + (counterDiameter / 2.0)), s = 0.0937 * displayWidth, y = 0.5 * (displayHeight - s);
      moveBoxSideLength = s;
      fill(black);
      square(x, y, s);
      fill(white);
      setMoveTextSize();
      String moveToShow = currentMove.toString();
      text (moveToShow, x + (s - textWidth(moveToShow)) / 2.0, y + 1.35 * (s - textHeight(moveToShow)));
    }
  }
}

void setMoveTextSize() {
  setCounterTextSize();
}

boolean inputCube_Unpressed = true, inputCube_mousePressed = false;

void inputCube() {
  inputCube_mousePressed = true;
  if (inputCube_Unpressed) {
    inputCube_Unpressed = false;
    inputCube = !inputCube;
    if (inputCube == true)
      defaultState();
    else
      solvedState();
    input = new RubiksCube_2x2(cubes);
    animationSetup();
  }
}

void displayCounter() {
  if (showCounter) {
    counter();
    showMove();
  }
  if (keepCounter) {
    counter(counterKeep);
    keepTimer++;
  } else
    keepTimer = 0;
}

void waitThen() {
  if (waitThenSolve)
    waitThenSolve();
  if (waitThenScramble)
    waitThenScramble();
}

    </script>
    <canvas id="sketch" style="border: 1px solid black;"></canvas>
    
  </body>
  
</html>
